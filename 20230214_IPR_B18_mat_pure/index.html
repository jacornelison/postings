<!DOCTYPE html>

<!--suppress HtmlDeprecatedAttribute -->
<head>
    <meta charset="utf-8">
    <title>IPR Analysis 2: B18 Sims</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Load up MathJax for math notation -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript"
            src="../mathjax/MathJax.js?config=TeX-AMS-MML_SVG">
            // src="../mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body>
<!-- Add my custom pager script -->
<script type="text/javascript" src="scripts/pager.js"></script>
<link rel="stylesheet" type="text/css" href="scripts/pager.css">

<header>
    <h1>Isotropic Polarization Rotation Analysis 2: B18 sims, Angle Estimators, and Forecasting</h1>

    <time datetime="2022-02-14" class="published updated">
        2023 Feb 14
    </time> â€”
    J. Cornelison
</header>

<hr>

\(
\newcommand{\Cl}{\mathcal{C}_\ell}
\newcommand{\Cb}{\mathcal{C}_b}
\newcommand{\oCb}{\mathcal{\hat C}_b}
\newcommand{\rCb}{\mathcal{C'}_b}
\newcommand{\Ccov}{\mathrm{\mathbf{C}}}
\newcommand{\siga}{\sigma_\alpha}
\newcommand{\sigasq}{\sigma_\alpha^2}
\newcommand{\choll}{\mathbf{L}}
\newcommand{\BX}{\textbf{X}}
\newcommand{\BY}{\textbf{Y}}
\newcommand{\BI}{\textbf{I}}
\newcommand{\BBE}{\mathbb{E}}
\)


<p>
In a previous posting <a href="JAC2023"></a>, I characterized the uncertainty in global polarization estimates for BICEP3 B2018 sims which are expected to have a mean angle of 0&deg;. This is a follow-up to that posting which now includes fits to the B18 3-year dataset and I compare angle fits to B18 to B2018.

</p>
<p>I find that the EB+TB fits are still greater than EB-only which implies that there was something wrong in the fitting function <tt>reduc_global_rotation</tt>. I show that this arose from not using all of the covariances between EB and TB in the Band Power Covariance Matrix (BPCM).
</p>

<p>
    I then create a linear estimator for our angles which will be compared to our &chi;<sup>2</sup>-estimator <tt>reduc_global_rotation</tt> throughout the analysis. I show that the linear estimator successfully reproduces angle estimates given from our &chi;<sup>2</sup>-estimator for B18 Lensed-Signal+Noise+Dust sims.
</p>

<p>
    Lastly, I show that both the BB-powers and angle variance of individual signals add linearly to the BB-powers and angle variances of the signal coadds. I find a simple scaling relation between BB-power and &sigma;<sub>&alpha;</sub><sup>2</sup> to create forecasts of angle uncertainties for scenarios such 50%-delensing of BB or acquiring a rough estimate of how many more observing years we would need until we are no longer noise-dominated.
</p>

<hr>

<section><h2>Matrix purifying B18 Sims</h2>
    <p>
I've now included B18 into these pagers. I am also now crossing Unlensed LCDM T&E with B of Dust-only and Noise-only signal types so that our angle estimates for these signal types are comparable to the ones with CMB already in them.
        These spectra can be seen in the "cmb x noise/dust" option where EB, TB, and BB are all now E<sub>CMB</sub>&times;B<sub>Noise/Dust</sub> , T<sub>CMB</sub>&times;B<sub>Noise/Dust</sub> , B<sub>CMB</sub>&times;B<sub>Noise/Dust</sub> respectively.
    </p>

<!--    <p>-->
<!--        Sim types:-->
<!--        <ol start="2">-->

<!--        <li>Unlensed &Lambda;CDM</li>-->
<!--        <li>Gaussian Dust</li>-->
<!--        <li>Unlensed &Lambda;CDM + r=0.1</li>-->
<!--        <li>Lensed &Lambda;CDM</li>-->
<!--        <li>Sign-flip noise</li>-->
<!--        <li>Lensed &Lambda;CDM+Noise [Type 5+6]</li>-->
<!--        <li>Lensed &Lambda;CDM+Noise+Dust [Type 7+3]</li>-->
<!--    </ol>-->
<!--    </p>-->
<!--    -->

    <ul>
        <li><b>B18</b> - the ensemble of 499 B18 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: fgh)</li>
        <li><b>B2018</b> - the ensemble of 499 B2018 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: h)</li>
        <li><b>B2018-rerun</b> - An ensemble of 10 B2018 sims I ran myself (sernum: 6600, daughter: h).</li>
    </ul>


    <figure>
        <img alt="Name pager" id="apspager" src="#" width="65%" onerror=this.src="figs/blank_6x6.png" />
        <figcaption>
            A pager of EB/TB APS of my 10 sims compared to the 499 sims generated for B2018. The gray lines indicate one realization and the black line indicates the mean of all realizations per-ell.
        </figcaption>
        <script type="text/javascript">
            pager.link("#apspager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure': ['None|','Matrix|matrix_'],
                    'Simset|sernum': ['B18|6614_fgh','B2018|6614_h','B2018-rerun|6600_h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                    'y-axes|axes': ['Fixed|_fixed','Free|_free']
                },
                function(params) {
                    return 'figs/aps_'+params.sernum+'_'+params.pure+params.sig+params.axes+params.c+'_bins_2_10.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': 'matrix_',
                'sernum': '6614_fgh',
                'c': '_cross',
                'axes': '_free',
            });
        </script>
    </figure>

    <p>I see a ~20% reduction in the B18 and B2018 matrix-purified Unlensed-LCDM BB spectra. Below I show the angle estimates now including crosses of Type-8 (L-LCDM+N+D) T and E with each signal type's B. As in my previous posting, I fit angles using only our standard &ell;-bins of 2 through 10 (out of 17).</p>

    <figure>
        <img alt="Name pager" id="histpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Histograms of &alpha; estimates for B2018 and my B2018-rerun for each EB/TB fit type; per signal type; and with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#histpager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure2': ['None|','Matrix|_matrix'],
                    'Simset|sernum2': ['B18|6614_fgh','B2018|6614_h','B2018-rerun|6600_h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                },
                function(params) {
                    return 'figs/'+params.sernum2+'_sig_'+params.sig+'_alpha_hist_bins_2_10_offdiag_2'+params.pure2+params.c+'_legacy.png';
                });
            pager.setparams({
                'sig': '2',
                'pure2': '_matrix',
                'sernum2': '6614_fgh',
                'c': '_cross',
            });
        </script>
    </figure>


<p>

</p>

    <p>
        Switching between B18 and B2018 for any signal type which has noise, we can qualitatively see that integrating over three years versus one reduces the &sigma;<sub>&alpha;</sub> as expected. Quantitatively though, we can calculate the effective number of additional years we integrated over by taking the ratio of the variances on &alpha;:
    </p>

    \begin{equation}
    \begin{split}
    &\sigma_{\alpha,B18}^2 = \frac{\sigma_{\alpha,B2018}^2}{N_{years}}\\
    & \\
    &N_{years} = \frac{\sigma_{\alpha,B2018}^2}{\sigma_{\alpha,B18}^2}\\
    \end{split}
    \end{equation}

    <p>
        and is tabluated below for each fit type:
    </p>



    <figure>
        <table>
            <tr>
                <th>Signal Type</th>
                <th colspan="3">Effective N<sub>years</sub></th>
            </tr>
            <tr>
                <th></th>
                <th>EB-only</th>
                <th>TB-only</th>
                <th>EB+TB</th>
            </tr>

            <tr>
                <td class=''>Noise-only</td>
                <td class=''>2.7368</td>
                <td class=''>2.6164</td>
                <td class=''>2.5918</td>
            </tr>

        </table>
    </figure>

    <p>The N<sub>years</sub>~2.6 for Noise-only which is close to what I get when I compare the B2018 survey weight to B18 according to the <a href="https://docs.google.com/spreadsheets/d/1k0uw5trXj5N3v-jLQMe3Z-CW_Q16NRae6zwKBb0Pxtg/view#gid=0">CMB Pol Expt Comparison Sheet</a> which is 552836/219441 = 2.52.</p>

    <p>We can also see that for B18, the means of the angles are still large compared to the error-on-the-mean, which disfavors the hypothesis in which the deviations were due to systematics resulting from using the B18 matrix on the B2018 subset. The next step is to test the other hypothesis where these deviations are due to the fact that we're using constrained T-maps.</p>
    <figure>
        <img alt="Name pager" id="eompager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption id="fig:eompager">
            Plots of the Mean divided the error on the mean as a function of each signal for cases with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#eompager",
                {
                    'Fit Type|fit' : ['EB Only|1','TB Only|2','EB+TB|3'],

                },
                function(params) {
                    return 'figs/m_over_eom_vs_sig_'+params.fit+'.png';
                });
            pager.setparams({
                'fit': '1',

            });
        </script>
    </figure>



</section>

<section>
    <h2>Looking into the Covariance Matrix</h2>

    <p>
        In Fig. 1.2 above, we see that the $\siga$ in the EB+TB fit is greater than $\siga$ from just EB-only. In the best case, EB and TB are perfectly uncorrelated and $\siga$ from from EB+TB is $\left(1/\sigasq {}^{EB}+1/\sigasq {}^{TB}\right)^{-\frac{1}{2}}$. Even if EB and TB exactly correlated and TB contributed no additional information then $\siga$ in the EB+TB fit would be equal to EB-only in the worst case and never greater than EB-only. So something must be wrong with the fitter when fitting EB and TB together.
    </p>

    Quoted from Justin's posting <a href="JBW2016"></a>:
    <i>
    <ul>
        As summarized in <a href="https://arxiv.org/abs/1312.7877">Kaufman et.
        al. (2013)</a>, we can modify a given input spectrum to include a
        uniform rotation of the CMB signal:</ul>

    \begin{align*}
    C'^{TB}_\ell &= C^{TE}_\ell \sin(2\alpha) \\
    C'^{EB}_\ell &= \frac 12 \left( C^{EE}_\ell - C^{BB}_\ell \right)
    \sin(4\alpha) \\
    \end{align*}



    <ul>
        We can then difference model expectation values \(\rCb^{XY}\) from the
            real bandpowers \(\oCb^{XY}\) (where the subscript \(b\) denotes binned
            bandpowers over a range in \(\ell\)) and calculate the \(Ï‡^2\) values
            making use of the bandpower covariance matrix \(\Ccov^{XY}\) for a
            given cross-spectrum \(XY\):
    </ul>
    \begin{equation}
    Ï‡^2 = \left( \oCb^{XY} - \rCb^{XY} \right)^\top \left( \Ccov^{XY}
    \right)^{-1} \left( \oCb^{XY} - \rCb^{XY} \right)
    \end{equation}
    </i>
    <p>First, since the code also allows for estimating &alpha; with EB+TB, I had assumed the above equation would be extended in such a way which considers the TBEB and EBTB cross-covariance in the full bandpower covariance matrix.
    </p>
    <p>
        If we use $\Ccov$ to describe the full bandpower covariance matrix between EB and TB with submatrices $\Ccov^{XY}$, I expected the covariance in the estimator to look like

    </p>

    \begin{equation}
    \Ccov =
    \begin{bmatrix}
    \Ccov^{TBTB} & \Ccov^{TBEB} \\
    \Ccov^{EBTB} & \Ccov^{EBEB} \\
    \end{bmatrix}
    \end{equation}

    <p>which would be taken directly from the final file's given bandpower covariance matrix (see the figure below for the EB, TB and EBTB blocks of the BPCM).</p>

    <figure>
        <img src="figs/EBTB_cov_plot.png">
        <figcaption>

        </figcaption>
    </figure>

    <p>
        Instead, the the code recalculates the bandpower covariance for just TBTB and EBEB doesn't actually include the cross-covariance between the two:
    </p>
    \begin{equation}
    \Ccov =
    \begin{bmatrix}
    \Ccov^{TBTB} & O \\
    O & \Ccov^{EBEB} \\
    \end{bmatrix}
    \end{equation}

    <p>
        Second, like our actual BPCM, the covariance matrix above is calculated from the final file's <tt>final.r.sim</tt> variable which are the 499 noise-debiased Type-7 sims (i.e. Lensed-LCDM+Noise-mean(Noise)).
    </p>

    <p>
        I re-fit alpha to the B18 Lensed-LCDM+Noise+Dust sims now using the full bandpower covariance matrix calculated from the 499 Lensed-LCDM+Noise+Dust realizations. To show the effects of only changing one thing at a time, in the pager below, the first "Full Cov." option uses the full, original covariance matrix (Noise-debiased L-LCDM+Noise). The "Full Cov. from Type 8" option uses the full covariance matrix recalculated from L-LDCM+Noise+Dust.
    </p>

    <figure>
        <img alt="Name pager" id="hist123pager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            pager.link("#hist123pager",
                {

                    'Cov. Mat.|cov12' : ['Original|legacy','Full Cov.|normal','Full Cov. from Type 8|normal_repsim_6614xxx8'],

                },
                function(params) {
                    return 'figs/'+params.sernum12+'_sig_'+params.sig12+'_alpha_hist_bins'+params.b12+'_offdiag_'+params.off12+'_matrix_'+params.cov12+params.pseudo12+'.png';

                });
            pager.setparams({
                'sig12': '8',
                'sernum12': '6614_fgh',
                //'c12': '_cross',
                'b12':'_2_10',
                'cov12': 'normal',
                'pseudo12' : '',
                'off12':'2',
            });
        </script>
    </figure>

    <p>
        Going from 'Original' to 'Full Cov.' we can see that EB-Only and TB-Only distributions stay the same as expected. The scatter on EB+TB does seem to improve, but it is still worse than EB-only, implying that something is still wrong here. Going from 'Full Cov.' to 'Full Cov. from Type 8', we can see the EB+TB drop to just below the EB-Only fit. This could imply that the covariances are being properly accounted for but perhaps that TB doesn't contribute any additional constraining power when included.
    </p>
    <p>
        This really drives home the importance of using the correct bandpower covariance matrix...
    </p>

    <h3>Angles from Pseudosims</h3>
    <h4>Pseudosims from Cholesky Decomposition</h4>
    <p>
        While no longer larger than EB-only, the $\siga$ of the EB+TB fits still aren't better than EB as we'd naively expect -- it seems weird that TB contains exactly zero additional information as these fits seem to suggest. The next thing I wanted to do was to try to determine if $\siga$ on EB+TB remain the same for simulations with covariances different from the ones in our current simsets. However, creating new sims from the pipeline is tedious, so I opted to create "pseudosims" of EB/TB bandpowers with arbitrary sample variance via Cholesky decomposition.
    </p>
    <p>
        Cholesky Decomposition is the decomposition of a matrix into the product of another matrix with itself (i.e. a sort of analog to taking the square-root of a matrix):

        \begin{equation}
        \text{Chol}\left(\mathbf{M}\right) = \choll\choll^T
        \end{equation}
    </p>

    <p>
        For given covariance matrix $\Ccov$, we can show that multiplying the Cholesky matrix $\choll$ by a set of uncorrelated random variables $\BX$ creates correlated random variables that also have a covariance matrix of $\Ccov$.
    </p>
    <p>
        We create a Cholesky matrix from our covariance matrix $\text{Chol}\left(\Ccov\right) = \choll\choll^T$ and we can define our newly generated correlated random numbers $\BY$ as
    </p>

    \begin{equation}
    \BY=\choll\BX
    \end{equation}
    <p>Where $\BX$ is uncorrelated random variables with a covariance matrix equal to the identity matrix $\BI$. The covariance matrix of $\BY$ is given by the expectation value $\BBE$ of $\BY\BY^T$ (assuming mean-zero for simplicity):</p>

    \begin{equation}
    \begin{split}
    \text{cov}\left(\BY\right) &= \BBE\left(\BY\BY^T\right)\\
    &= \BBE\left(\left(\choll\BX\right)\left(\choll\BX\right)^T\right)\\
    &= \BBE\left(\choll\BX\BX^T\choll^T\right)\\
    &= \choll\,\BBE\left(\BX\BX^T\right)\choll^T\\
    &= \choll\BI\choll^T\\
    &= \choll\choll^T\\
    &\\
    \text{cov}\left(\BY\right) &= \Ccov\\

    \end{split}
    \end{equation}
<p>
    For non-mean-zero distributions, we carry around some extra terms, but the answer is still the same.
</p>
    <p>
        For the purpose of this posting, I create Cholesky matrices using Matlab's built-in <tt>chol.m</tt> function which makes creating millions of pseudosims with whatever covariance matrix I want within seconds.
        The figure below shows the EB/TB BPCM calculated from B18's 499 Type 8 Lensed-Signal+Noise+Dust sims and compares it to the covariance matrix calculated from 10 million pseudosims created from the B18 Type 8 BPCM (i.e. Comparing $\Ccov$ to $\text{cov}(\BY)$).
    </p>

    <figure>
        <img src="figs/B18_vs_pseudo_cov_compare.png" width="100%">
        <figcaption>
            <p><b>Left:</b> EB/TB blocks of the bandpower covariance matrix of the 499 B18 Lensed-LCDM+Noise+Dust sims.</p>
            <p><b>Middle:</b> BPCM calculated from 10 million pseudosims which were constructed from the B18 BPCM.</p>
            <p><b>Right:</b> The fractional difference of the two matrices,
                $(\Ccov_{B18}-\Ccov{pseudo})/\Ccov_{B18}$</p>
            <p><b>Note:</b> Some "pixels" of the BPCM are negative, so to show the plots in logspace, I plotted the absolute value of the BPCM (and fractional difference) instead.</p>
        </figcaption>
    </figure>

<p>
    The covariances of the reconstructed BPCM have a fractional difference of <1% for most bins within one or two bins next to the diagonals.
</p>
<h4>Fitting Angles to Pseudosims</h4>

    <p>
        Next, I fit angles to pseudosims of mean-zero EB and TB spectra for different cases of covariance matrices. Each case includes 499 sims in order to be directly comparable to the distributions from our standard 499 sims (included in the pager below). The estimator includes the fix described above where we use the full BPCM's.

    <p>Cases:</p>
    <ul>
        <li><b>B18 Pseudosims:</b> pseudosims from the B18 L-LCDM+Noise+Dust BPCM for a direct comparison.</li>
        <li><b>No EBTB Cov:</b> Given that including the EBTB and TBEB blocks seemed to improve things in the first section, I also create sims where the EBTB and TBEB blocks are zeroed out but the EBEB and TBTB covariances are the same as the B18 covariance matrix.</li>
        <li><b>Abs B18 Cov:</b> Pseudosims constructed from the absolute value of the entire B18 BPCM (the EBTB/TBEB blocks are not zeroed).</li>
    </ul>

    <figure>
        <img alt="Name pager" id="pseudohistpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption id="psh">

        </figcaption>
        <script type="text/javascript">
            pager.link("#pseudohistpager",
                {
                    'Case|mat': ['B18 Standard Sims|standard','B18 Pseudosims|pseudo','No EBTB Cov|noebtbcov', 'Abs B18 Cov|abscov'],
                },
                function(params) {
                    return 'figs/pseudo_alpha_hist_B18_'+params.mat+'.png';
                });
            pager.setparams({
                'mat': 'standard',
            });
        </script>
    </figure>

<p>
The pager above is mostly to show that the distributions look nominal compared to the B18 Type-8 distribution. Because we're only using 499 sims, we expect the uncertainty on $\siga$ to be around 3% of the parent distribution (see &sect; 3.2 of <a href="JAC2023"></a>) and the $\siga$ of the B18 pseudosims match that of the B18 standard within that threshold. The table below compares $\siga$ of the EB, TB and EB+TB fits among the various cases with the <b>Naive EB</b> column showing what we would expect is EB and TB were perfectly uncorrelated.
</p>

    <figure class="table">
        <table>


            <tr>
                <th></th>
                <th class="cstart" colspan="3">&sigma;<sub>&alpha;</sub> [Deg]</th>
                <th class="cstart"></th>
            </tr>
            <tr>
                <th>Case</th>
                <th class="cstart">EB</th>
                <th>TB</th>
                <th>EB+TB</th>
                <th class="cstart">Naive EB+TB</th>
            </tr>
            <tr>
                <td class=''>B18 Standard</td>
                <td class='cstart'>0.0747</td>
                <td class=''>0.1412</td>
                <td class=''>0.0746</td>
                <td class='cstart'>0.0660</td>
            </tr>
            <tr>
                <td class=''>B18 Pseudo</td>
                <td class='cstart'>0.0752</td>
                <td class=''>0.1423</td>
                <td class=''>0.0744</td>
                <td class='cstart'>0.0665</td>
            </tr>
            <tr>
                <td class=''>No EBTB Cov</td>
                <td class='cstart'>0.0729</td>
                <td class=''>0.1422</td>
                <td class=''>0.0645</td>
                <td class='cstart'>0.0648</td>
            </tr>
            <tr>
                <td class=''>Abs B18 Cov</td>
                <td class='cstart'>0.0743</td>
                <td class=''>0.1386</td>
                <td class=''>0.0644</td>
                <td class='cstart'>0.0655</td>
            </tr>

        </table>
    </figure>

    <p>This is telling us is that </p>
    <ol type="A">
        <li><b>B18 Pseudo:</b> The issue with EB+TB fits is reproducible with pseudosims.</li>
        <li><b>No EBTB Cov:</b> That we now see such a large improvement in the EB+TB fit, this confirms that the covariance in the EBTB/TBEB blocks is such that any additional information from TB is effectively being ignored.</li>
        <li><b>Abs B18 Cov:</b> Specifically, the fact that we have negative covariances are to blame for this, since we see an improvement on EB+TB $\siga$ when we use covariances of the same amplitude that are made positive.</li>
    </ol>
    <p>It's not clear to me why having negative EBTB covariance would have such an impact on the fit. Intuitively, I think $\siga$ should be the same regardless of the sign of the covariance, shouldn't it?</p>

</section>

<section>
    <h2>Constraining power vs. &ell;</h2>
    <p>We want to look at the constraining power per-&ell; between the EB and TB spectra (i.e. determine which bandpowers contribute most to &alpha; considering both the model and our bandpower uncertainties).
        We currently only use our canonical science bins (bins 2 through 10) and this exercise will be useful in determining if we might want to include higher bins in the analysis as well.
<!--        This is represented by the expectation values of our model given some input angle, normalized by that input angle and weighted by the inverse of the sample variance of the individual bandpowers.-->
    </p>
    <p>
        For some arbitrarily small input angle &epsilon;<sub>&alpha;</sub>, we get some spectra out of our model, C<sub>b</sub>. Because &epsilon;<sub>&alpha;</sub> is small and the small angle approximation applies, the shape of C<sub>b</sub> should be constant and only linearly scale by &alpha;. Thus we normalize the shape of the model spectra by dividing C<sub>b</sub> by &epsilon;<sub>alpha</sub> -- in the case of uniform weighting, this alone would tell us which bandpowers contribute most to the contraints on &alpha; with the higher values of C<sub>b</sub>/&epsilon;<sub>alpha</sub> possessing higher constraining power. However, this doesn't consider the uncertainties on the bandpowers themselves, so we weight the C<sub>b</sub>/&epsilon;<sub>alpha</sub> by the inverse of the bandpower sample variance which we get from sims.
    </p>

    <p>In application, I calculate the EB and TB expectation values using <tt>reduc_global_rotation</tt>'s subfunction <tt>pol_rot_theory_model</tt> using our fiducial input model from B18's final file with an input angle of 0.001&deg; -- this angle is arbitrary as it could be any value as long as it satisfies the small-angle approximation. I divide the expectation values by the input angle and then divide the model spectra by the per-bandpower standard deviation of B18's 499 Lensed-LCDM+Noise+Dust EB and TB sims . In the plot below, take the absolute value since TB can be negative and I peak normalize to show the relative constraining power in EB and TB.</p>

    <figure>
        <img src="figs/constraining_power_6614_fgh.png" width="100%"/>
        <figcaption>
            <b>Top</b> Model EB and TB bandpowers for some arbitrary input angle, normalized by the input angle. <b>Middle</b> Log-Y plot of the inverse variance of the spectra per-bandpower. <b>Bottom</b> Relative constraining power of EB and TB spectra (multiplying the top plot by the middle plot and peak normalizing). Higher values indicate higher constraining power. The dots are bins that are normally used during our global rotation analysis of real CMB data and X's are bins that are not normally used.
        </figcaption>
    </figure>

    <p>
        There are a couple of points to note from the plot above:
    </p>
    <ul>
        <li>We can see that in the top plot that TB would have more constraining power in EB, but this is countered by the fact that TB has much higher sample variance compared to EB.</li>
        <li>
            Most of our constraining power for EB is in the &ell;-range of ~270 to 450, only two bins of which we are actually using.
        </li>
        <li>
            For TB, most constraining power comes from the &ell;-range of ~250 to 350, bracketed by the &ell; values where the TB signal pivots around zero, but it still less than half as good as EB.
        </li>

    </ul>

    <p>
        In his posting, Justin explored the benefits of including higher &ell;-ranges and the plot above provides a good argument for looking into doing that again for this analysis.
    </p>


</section>


<section>
        <h2>Angle Linear Estimator</h2>
<p>We want to create a linear estimator that we can compare throughout the analysis which would provide a nice (and fast) consistency check between the two estimators.</p>

    <h3>Creating a Linear Estimator</h3>

    <p>
        We can linearize a function by Taylor-expansion around zero (in matrix form)
    </p>

    \begin{equation}
    \begin{split}
    f(X) &= f(O) + \nabla f(O)\cdot\left(X-O\right)\\
    \end{split}
    \end{equation}

    <p>
        where <b>X</b> is an array of data and <b>O</b> is an array of zeros and assuming the values of <b>X</b> are small.</p>

    <p>
        In our case, our f is just &alpha; which is a function of our EB, TB, or EB+TB bandpowers $C_b^{XY}$ and we know that &alpha;=0 when $C_b^{XY}=O$.
    </p>

    \begin{equation}
    \begin{split}
    \alpha(\hat{C}_b^{XY}) &= \alpha(0) + \frac{\partial\alpha}{\partial C_{b}^{XY}}\,\cdot\,\left(\hat{C}_{b}^{XY}-0\right)\\
    \end{split}
    \end{equation}

<p>

    Assuming the above is linear for small values of &alpha; (which should be true given the small-angle approximation), we can create a linear estimator, $\hat{\alpha}_{lin}$, in which &alpha; is the dot product between the our array of bandpowers $C_{b}^{XY}$ and some vector that contains the information how each bandpower contributes to &alpha;</p>

    \begin{equation}
    \begin{split}
    \hat{\alpha}_{lin} &= \frac{\partial\alpha}{\partial C_{b}^{XY}}\,\cdot\,\hat{C}_{b}^{XY}\\
    \end{split}\label{linest}
    \end{equation}

    <p></p>

        <p>
            We want our linear estimator to consider all of the information contained in the BPCM, so I calculate $\partial\alpha\,/\,\partial C_{b}^{XY}$ by injecting a quasi-delta function -- i.e. setting a bandpower to some fixed amplitude whilst keeping all other bandpowers at zero -- into an EB or TB spectra &ell;bin-by-&ell;bin, recording the resulting alpha estimates from the &chi;<sup>2</sup>-estimator (see below figure for example). I fit angles to these fake spectra using the same procedure outlined in <a href="JAC2023"></a> where, I substitute the real data in B18's final file for these fake spectra and then pass that final file through <tt>reduc_global_rotation.m</tt>. Because I want to compare to B18 Lensed-LCDM+Noise+Dust, I use B18's the BPCM calculated from those 499 realizations.</p>
        <figure>
            <img src="figs/estimator_xfer_example.gif">
            <figcaption>

            </figcaption>
        </figure>
    <p>
        For the EB+TB fits, I inject the delta function into EB and the TB sequentially while telling <tt>reduc_global_rotation.m</tt> to fit both spectra at once. This not only uses the EBEB and TBTB covariances, but also uses the EBTB covariance from the BPCM as well.
    </p>

    <p>
            The figure below shows resulting alphas for four different amplitudes of our quasi-delta function. Through my analysis so far, I have been using our standard &ell;-bins 2-10 but I now also include a case for using &ell;-bins 2-15. We get $\partial\alpha\,/\,\partial C_{b}^{XY}$ be simply dividing the output array of alphas by in input amplitude of the bandpower (i.e. the line in the left plot of the below fig divided by Dl in the legend which is show on the right plots).
        </p>

    <figure>
        <img alt="Name pager" id="xferpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption id="dAdD">
            Exploring the effect on &alpha; for input delta functions for EB <b>(Top Row)</b> and TB <b>(Bottom
            Row)</b>. <b>Left Column</b> Resulting &alpha; estimate per bandpower as a function of Ell, the lines are color coded by the amplitude of the quasi-delta function used in the given spectra. <b>(Right Column)</b> The angle at each bandpower is divided by the bandpower itself which creates the linear estimator. Since all four cases overlap, this is also a proof of linearity for this range of bandpowers.
        </figcaption>
        <script type="text/javascript">
            pager.link("#xferpager",
                {
                    'Bins|bins2': ['2-10|2_10','2-15|2_15'],
                },
                function(params) {
                    return 'figs/estimator_xfer_func_bins_'+params.bins2+'.png';
                });
            pager.setparams({
                'bins2': '2_10',
            });
        </script>
    </figure>

<p></p>


    <h3>Comparing &alpha; estimates</h3>
    <p>
         The below pager shows the angles from the linear estimator (applying Eq. \ref{linest}) compared to those derived from our standard chi-squared estimator $\hat{\alpha}_{\chi}$.
    </p>
    <figure>
        <img alt="Name pager" id="linestpager" src="#" onerror=this.src="figs/blank_6x4.png" width="75%"/>
        <figcaption>
            Each dot represents a single realization from B18. &alpha; along the y-axis is calculated by taking the dot product of d&alpha;/dD<sub>&ell;</sub> with their respective band powers for each realization.
        </figcaption>
        <script type="text/javascript">
            pager.link("#linestpager",
                {

                    'Bins|bins2': ['2-10|2_10','2-15|2_15'],
                },
                function(params) {
                    return 'figs/alpha_chi_vs_linear_type_6_bins_'+params.bins2+'.png';
                });
            pager.setparams({
                'bins2': '2_10',
            });
        </script>
    </figure>

    <p>We can see that the angles from $\hat{\alpha}_{lin}$ are nearly exact compared to $\hat{\alpha}_{\chi}$.</p>

    <h3>Comparing uncertainty estimates</h3>
    <p>I determine &sigma;<sub>&alpha;</sub> by taking the dot product of $\partial\alpha\,/\,\partial C_{b}^{XY}$ and the standard deviation per-bandpower across all sims in the B18 simset.</p>

    \begin{equation}

    \sigma_{\alpha} = \frac{\partial\alpha}{\partial C_{b}^{XY}} \cdot \text{SDEV}\left(\hat{C}_{b}^{XY}\right)

    \end{equation}

    <p></p>

    <figure>
        <img alt="Name pager" id="estsigpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Left plots show the contribution of &sigma;<sub>&alpha;</sub> per-bandpower for EB and TB from the linear estimator. The right plot compares the &sigma;<sub>&alpha;</sub> between the linear and chi-squared estimator.
        </figcaption>
        <script type="text/javascript">
            pager.link("#estsigpager",
                {
                    'Bins|bins2': ['2-10|2_10','2-15|2_15'],
                },
                function(params) {
                    return 'figs/sigalpha_lin_vs_chi_bins_'+params.bins2+'.png';
                });
            pager.setparams({
                'bins2': '2_10',
            });
        </script>
    </figure>

    <p>The estimation of &sigma;<sub>&alpha;</sub> we get from the linear estimator is within a few percent of those given by the &chi;<sup>2</sup> estimator (which are given by the standard deviation of the distributions of &alpha;).</p>
</section>

<section>
    <h2>Forecasting Angle Uncertainty from BB power</h2>
<p>
    In this section, we look into a simple forecasting technique that we can use to provide an educated guess on our limits on an IPR constraint in future analysis.
    i.e. predicting a $\siga$ givin some reduction in BB power in either lensing signal, noise, or dust.
    For context, this exercise is mostly to provide the foundation on a discussion of future analyses in our paper.
    In &sect; 3, we found that including higher &ell;-bins might be in our best interest. For the exercise below, I'm keeping the bin range at our default 2 through 10 and we can revisit this if we change our minds later.

</p>
    <p>We can show that the variance on &alpha; of the individual signal types add linearly to the variance of angles of the coadded signals. The same can be shown for that of BB power. The table below shows the variance from each fit-type and BB power for each signal type. In the middle and bottom sets of rows (i.e. the &sigma;<sup>2</sup>-rows), I compare the sum of the variances of the individual signal types to the variance of the coadded spectra of those signal types. We can see pretty clearly that the sum of the variances is equal to the variance of the coadded spectra to <5% for TB and <1% for EB, EB+TB, and BB-power.
</p>

    <figure class="table">
        <table>
            <tr>
                <th>Signal</th>
                <th class="cstart">EB</th>
                <th>TB</th>
                <th>EB+TB</th>
                <th class="cstart">BBmean</th>
            </tr>

            <tr>
                <th></th>
                <th class="cstart" colspan="3">&sigma;<sub>&alpha;</sub><sup>2</sup> [Deg<sup>2</sup>]</th>
                <th class="cstart">[&mu;K<sup>2</sup>]</th>
            </tr>

            <tr>
                <td class=''>Lensed-LCDM</td>
                <td class='cstart'>0.0026</td>
                <td class=''>0.0094</td>
                <td class=''>0.0026</td>
                <td class='cstart'>0.0109</td>
            </tr>
            <tr>
                <td class=''>Noise</td>
                <td class='cstart'>0.0027</td>
                <td class=''>0.0110</td>
                <td class=''>0.0027</td>
                <td class='cstart'>0.0167</td>
            </tr>
            <tr>
                <td class=' rend'>Dust</td>
                <td class='cstart rend'>0.0003</td>
                <td class=' rend'>0.0009</td>
                <td class=' rend'>0.0003</td>
                <td class='cstart rend'>0.0007</td>
            </tr>
            <tr>
                <td class=''>&sigma;<sup>2</sup><sub>L</sub>+&sigma;<sup>2</sup><sub>N</sub></td>
                <td class='cstart'>0.0053</td>
                <td class=''>0.0204</td>
                <td class=''>0.0053</td>
                <td class='cstart'>0.0276</td>
            </tr>
            <tr>
                <td class=' rend'>&sigma;<sup>2</sup><sub>L+N</sub></td>
                <td class='cstart rend'>0.0053</td>
                <td class=' rend'>0.0194</td>
                <td class=' rend'>0.0053</td>
                <td class='cstart rend'>0.0276</td>
            </tr>
            <tr>
                <td class=''>&sigma;<sup>2</sup><sub>L</sub>+&sigma;<sup>2</sup><sub>N</sub>+&sigma;<sup>2</sup><sub>D</sub></td>
                <td class='cstart'>0.0056</td>
                <td class=''>0.0213</td>
                <td class=''>0.0056</td>
                <td class='cstart'>0.0284</td>
            </tr>
            <tr>
                <td class=' rend'>&sigma;<sup>2</sup><sub>L+N+D</sub></td>
                <td class='cstart rend'>0.0056</td>
                <td class=' rend'>0.0199</td>
                <td class=' rend'>0.0056</td>
                <td class='cstart rend'>0.0283</td>
            </tr>


        </table>
    </figure>

    <p>
        Because both add linearly, we can derive a simple scaling relation between $\sigasq$ and mean BB power which can then be used to estimate a $\sigasq$ for changes in BB power of a given signal type. The first scenario we consider is delensing, where we are able to reduce the BB power from the lensing signal by a flat 50% across all &ell;-bins. The second is the reduction in noise by incorporating data through 2022 -- B18 has effectively 2.5 years of data and I assume that B2019 through B2022 are just as good as B2018. The last I consider is just combining both B22 with a 50% delensing.
    </p>

    <p>The table below shows these scenarios for L-LCDM+N+D, EB-only fits again assuming we use only bins 2 through 10. For easy comparison, I include the &sigma;<sup>2</sup><sub>L+N+D</sub> from the table above along with a column showing $\siga$.</p>

    <figure class="table">
        <table>
            <tr>
                <th>Signal</th>
                <th colspan="2" class="cstart">EB</th>
                <th class="cstart">BBmean</th>
            </tr>

            <tr>
                <th></th>
                <th class="cstart">&sigma;<sub>&alpha;</sub></th>
                <th class="cstart" colspan="1">&sigma;<sub>&alpha;</sub><sup>2</sup> [Deg<sup>2</sup>]</th>
                <th class="cstart">[&mu;K<sup>2</sup>]</th>
            </tr>

            <tr>
                <td class=''>B18 No Delensing</td>
                <td class='cstart'>0.0747</td>
                <td class='cstart'>0.0056</td>
                <td class='cstart'>0.0283</td>
            </tr>
            <tr>
                <td class=''>B18+50% Delensing</td>
                <td class='cstart'>0.0666</td>
                <td class='cstart'>0.0044</td>
                <td class='cstart'>0.0229</td>
            </tr>
            <tr>
                <td class=''>B22+No Delensing</td>
                <td class='cstart'>0.0653</td>
                <td class='cstart'>0.0043</td>
                <td class='cstart'>0.0220</td>
            </tr>
            <tr>
                <td class=''>B22+50% Delensing</td>
                <td class='cstart'>0.0568</td>
                <td class='cstart'>0.0032</td>
                <td class='cstart'>0.0166</td>
            </tr>

        </table>
    </figure>

    <p>We can expect a ~20% reduction in $\siga$ in either case of only delensing or only including more years and a ~25% reduction if we do both.</p>

</section>

<section><h2>Conclusions</h2>
    <p>
        <ul>
        <li>The issues where $\siga$ in the EB+TB fits were worse than just using EB-only appear to come from not using EBTB and TBEB cross-covariance of the BPCM. Further, I find that the EB+TB $\siga$ are still nearly equal to EB-only when we have negative covariances but see an improvement in EB+TB fits when I substitute the absolute value of the BPCM instead.</li>
        <li>Plots of the contraining power vs &ell;-bin suggests that most of our constraining power for &alpha; is actually in the upper half of our &ell;-range and that we can improve $\siga$ by up to 30% by including &ell;-bins from 11 to 15.</li>
        <li>I have created a created a linear estimator derived from our &chi;-squared estimator that is capable of producing nearly identical fits on &alpha;. This estimator will be used as a cross-check throughout the rest of the analysis.</li>
        <li>I also find that, because both $\sigasq$ and BB-power both add linearly, we can establish a simple scaling relationship between the two which can provide rudimentary estimates on the sample variance of future analyses where we've reduced the BB power by e.g. delensing, including more years, etc...</li>
    </ul>
    </p>

</section>

<hr>

<section class="appendix">

<h2 class="appendix">Appendix</h2>
<h3>EB vs TB plots</h3>

    <figure>
        <img alt="Name pager" id="ebvtbpager" src="#" onerror=this.src="figs/blank_6x4.png" width="75%"/>
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            pager.link("#ebvtbpager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pureA': ['None|','Matrix|matrix_'],
                    'Simset|sernumA': ['B18|6614fgh','B2018|6614h','B2018-rerun|6600h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                },
                function(params) {
                    return 'figs/alpha_eb_vs_tb_'+params.sernumA+params.pureA+params.sig+'_corr'+params.c+'_bins_2_10.png';
                });
            pager.setparams({
                'sig': '2',
                'pureA': 'matrix_',
                'sernumA': '6614fgh',
                'c': '_cross',
            });
        </script>
    </figure>


    <h3>Footnotes</h3>
    <p>Click on the number to return to the main text.</p>
    <div class="footnote">
        <p>
        <sup><a name="ftn1" href="#sup1">[1]</a></sup>

    </p>
    </div>
<!--    <h3>Code</h3>-->
<!--    <p>Below is a list of code that was used for this analysis. The code is committed to the pipeline and can be found in the <tt>analysis/beammap/</tt> directory.</p>-->
<!--    <p id="code"></p>-->

<!--    <h3>Data</h3>-->
<!--    <p id="data"></p>-->
    <h3>References</h3>

    <p id="references"></p>


    <p id="testp"></p>



    <script type="text/javascript">

        // Shorthand tags
        var codes = [
            "rps_fit_mirror_from_moon.m",
            ];

        // Posting titles
        var desc = [
            "Derives mirror parameters from observations of the moon.",
        ];

        // Make a list of references
        var post = document.getElementById("code");
        var msg = "<table class=\"code\">";
        for (var code in codes){
            msg = msg + "<tr><td><tt>"+codes[code]+"</tt></td><td> - </td><td>"+desc[code]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

    </script>

    <script type="text/javascript">

        // Shorthand tags
        var data = [
            "moonsch.mat",
            ];

        // Posting titles
        var desc = [
            "Metadata of Moon observations",
            ];

        // Make a list of references
        var post = document.getElementById("data");
        var msg = "<table class=\"code\">";
        for (var datum in data) {
            msg = msg + "<tr><td><tt>" + data[datum] + "</tt></td><td> - </td><td>" + desc[datum] + "</td>";
        }
        ;
        msg = msg + "</table>";
        post.innerHTML = msg;

    </script>



    <script type="text/javascript">

        // This my way of making shorthand links.
        // We'll make a couple arrays with the 'tag' and href information
        // and then look through each anchor element for the specified tag.
        // The anchors should then just look like: <a href="tagname"></a>
        // and the script will automatically fill in the hyperlings and text.


        var posting_dir = window.location.href; // What's the current url?

        var bkurl = "bicep.rc.fas.harvard.edu";
        var spurl = "bicep.usap.gov";

        // These are the possible places to find postings
        // The strings are for if you post your posting in that directory.
        var sitemap = {
            jcornelison: "../../../",   // /jcornelison/postings/
            bkcmb : "../../../../",     // /bkcmb/analysis_logbook/analysis/
            bicep3: "../../../",        //
            bicep_array: "../../../",   //
            bicep2: "",                 // We shouldn't be posting in these, but still have postings we can reference.
            keck  : "",                 // keck/analysis_logbook/analysis/
            spuder: "",                 // ~spuder/hieno_analysis_logboo
            bicep1: "",                 // ~bicep1/analysis_logbook_north/
            general_projects:"",
                   };
        // Logbook Site map:
        // personal:www/jcornelison/postings/
        // bkcmb:   www/bkcmb/analysis_logbook/analysis/
        // keck:    www/keck/analysis_logbook/analysis/
        // BICEP3:  www/bicep3/analysis_logbook/
        // BA:      www/bicep_array/analysis_logbook/
        // We shouldn't be posting in these, but still have postings.
        // bicep2:
        // keck:    www/keck/analysis_logbook/analysis/
        // spuder:  www/~spuder/hieno_analysis_logbook/
        // bicep1:  www/~bicep1/analysis_logbook_north/

        // Shorthand tags
        var tags = [
            "Carroll1990",
            "Harari1992",
            "Kaufman2013",
            "JBW2016",
            "EWB2016",
            "BKIX",
            "BKXII",
            "BKXIV",
            "BKXVII",
            "JAC2023",
        ];

        // Links
        // Truncate the link down to the www directory in which it lies if you can.
        // This ensures that we can view the linked postings at Pole without the internet.
        var hrefs = [
            "papers/carroll1990.pdf",
            "papers/harari1992.pdf",
            "https://arxiv.org/pdf/1312.7877.pdf",
            "bkcmb/analysis_logbook/analysis/20160907_polrot/",
            "bkcmb/analysis_logbook/analysis/20161215_rot_sims_polrot/",
            "https://arxiv.org/pdf/1705.02523.pdf",
            "https://arxiv.org/pdf/2011.03483.pdf",
            "https://arxiv.org/pdf/2108.03316.pdf",
            "https://arxiv.org/pdf/2210.08038.pdf",
            "bkcmb/analysis_logbook/analysis/20230207_IPR_angle_fits_to_B2018/",


        ];


        // Posting titles
        var desc = [
            "Limits on a Lorentz- and parity-violating modification of electrodynamics",
            "Effects of a Nambu-Goldstone boson on the polarization of radio galaxies and the cosmic microwave background",
            "Self-Calibration of BICEP1 Three-Year Data and Constraints on Astrophysical Polarization Rotation",
            "Birefringence/Polarization rotation in K2015 and BK15",
            "Polarization Rotation Sims Global Rotation",
            "New Bounds on Anisotropies of CMB Polarization Rotation and Implications for Axion-Like Particles and Primordial Magnetic Fields",
            "Constraints on axion-like polarization oscillations in the cosmic microwave background",
            "Improved Constraints on axion-like polarization oscillations in the Cosmic Microwave Background",
            "Line of Sight Distortion Analysis: Estimates of Gravitational Lensing, Anisotropic Cosmic Birefringence, Patchy Reionization, and Systematic Errors",
            "Isotropic Polarization Rotation Analysis: Global Polarization Rotation Fits on Standard B2018 Sims",
        ];
        // Debug



        var preface = "";
        var keys = Object.keys(sitemap);
        // If we're not at pole or bicep, just post the full URL
        // If we are, go back to the www directory.
        if (posting_dir.match(new RegExp(bkurl))!=bkurl &
            posting_dir.match(new RegExp(spurl))!=spurl){
                preface = "http://" + bkurl+"/";
            }
        else {
            for (key in keys){
                if (posting_dir.match(new RegExp("/"+keys[key]+"/"))=="/"+keys[key]+"/"){
                    preface = sitemap[keys[key]];
                };
            };

        };

        // Add the prefixes we can.
        // Only add prefixes to directories in the sitemap so we don't break
        // external references.
        for (ref in hrefs) {
            for (key in keys) {

            // If there's a match, at the prefix and move on.
            if(hrefs[ref].match(new RegExp(keys[key] + "/"))==keys[key]+"/"){
                hrefs[ref] = preface+hrefs[ref];
                break;
            }
            };
        };

        // posty.innerHTML = preface;

        // Make a list of references
        var post = document.getElementById("references");
        var msg = "<table>";
        for (var tag in tags){
            msg = msg + "<tr><td><a href="+tags[tag]+"></a></td><td> - </td><td>"+desc[tag]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

        // Look through all the hyperlinks and insert the proper links to the postings
        var links = document.getElementsByTagName("A");
        for (var link in links){
            for (var tag in tags){
                if (links[link].href.endsWith(tags[tag])){
                    links[link].text = "("+tags[tag]+")";
                    links[link].href = hrefs[tag];
                    links[link].target = "_blank";
                }
            }
        }

    </script>
</section>




</body>
