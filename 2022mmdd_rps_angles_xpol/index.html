<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <title>RPS Results Summary — J. Cornelison</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Load up MathJax for math notation -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript"
            src="../mathjax/MathJax.js?config=TeX-AMS-MML_SVG">
            // src="../mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body>
<!-- Add my custom pager script -->
<script type="text/javascript" src="scripts/pager.js"></script>
<link rel="stylesheet" type="text/css" href="scripts/pager.css">

<header>
    <h1>RPS Analysis: Summary of RPS-derived Polarization Parameters (WIP)</h1>

    <time datetime="2020-xx-xx" class="published updated">
        2023 Feb 20
    </time> —
    J. Cornelison
</header>

<hr>

To discuss: <a href="#abanticorr">A/B anticorrelations</a>

<hr>
<!--
- This is a presentation of the RPS-derived angles
- These are the schedules we used during the measurement
- This is how we fit angles
- These are the angles
-- phi-pair, phia, phib
-- compared fiducial
- This section attempts to understand the uncertainties
-->
<section><h2>Introduction</h2>
\(
    \newcommand{\xpol}{\epsilon}
    \newcommand{\phis}{\phi_s}
    \newcommand{\phid}{\phi_d}
    \)
<h3>RPS Analysis in a nutshell</h3>

    <p>
        The general approach to converting the RPS data to estimations on the polarization angles and cross-polar response of a given detector is to done in two parts: fit 2D Gaussians to a rasterstet to derive the amplitudes of a modulation curve and then fit a sinusoidal function to the modulation curve to derive the polarization angle and cross-polar response (see Figure 1.1 below).
    </p>

    <figure>
        <img src="figs\spie_mod_curve.png"/>
        <figcaption>

        </figcaption>
    </figure>


    <p>The Gaussian we fit is done at the timestream level in raw mount coordinates <a href="KWY2007"></a> and is of the form:</p>

    \begin{equation}
    \label{eq:beam}
    B(\mathbf{x}) = A e^{(\mathbf{x}-\mathbf{\mu})^T\Sigma^{-1}(\mathbf{x}-\mathbf{\mu})}
    \end{equation}
    Where $A$ is the amplitude, $\mathbf{\mu} = (Az_0\,\,El_0)$ is the beam centroid, and

    \begin{equation}
    \Sigma =
    \begin{bmatrix} \sigma_{Az}^2& \rho \sigma_{Az} \sigma_{El} \\ \rho \sigma_{Az} \sigma_{El} & \sigma_{El}^2 \end{bmatrix}
    \end{equation}

    <p>
        where $(\sigma_{Az},\,\sigma_{El})$ is the beam width, and $\rho$ is the beam ellipticity. The significant difference between this analysis and other analyses involving beams is that we include 13 amplitude parameters to account for each beam in the modulation curve while fitting only a single $Az_0$, $El_0$, $\sigma_{Az}$, $\sigma_{El}$, and $\rho$ parameter across all the beams in a rasterset. This is to mitigate pointing effects from the Roger Effect <a href="RWO2013"></a> and to allow good beam centroid fits for rasters during which the RPS angle is orthogonal to a given detector and the SNR on the beam amplitude is low.
    </p>

    <p>Once we have our modulation curve, we could fit a sinusoidal function of the form:</p>

    \begin{equation}\label{eq:modcurve}
    A(\zeta) = G\left(\cos\left(2\left(\zeta+\psi\right)\right)-\frac{\epsilon+1}{\epsilon-1}\right)\left(n_1\cos(\zeta)+n_2\sin(\zeta)+1\right)
    \end{equation}
    <p>
        where $G$ is the detector gain, $\zeta$ is the RPS angle WRT gravity, $\psi$ is the detector polarization angle with respect to the source, $\epsilon$
        is the detector cross-polar response, and ($n_1,\,n_2$) are nuisance parameters to account for miscollimation of the source rotation axis.
    </p>
    <p>
        The polarization angle $\psi$ in Equation \ref{eq:modcurve} is a relative measurement and is agnostic to the orientation of the focal plane.
        We define an angle $\phi_d$, which is the polarization angle of a detector with respect to the &theta;=0 axis -- this gives us a set of parameters in cartesian coordinates $(x,\,y,\,\phi_{d})$ which is analogous to the polar set of $(r,\,\theta,\,\chi)$ [See <a href="JAC2019"></a>]. This is done by combining $\psi$ with the angle measured from the telescope's &theta;=0 axis and the RPS's &zeta;=0 axis, called $\phi_s$, which is computed through the pointing model.
    </p>
    \begin{equation}
    \phi_d = \psi + \phi_s
    \end{equation}

    <p>The figure below shows a simple diagram of how the $\phis$, $\psi$, and $\phid$ all relate the focal plane orientation and to each other.</p>

    <figure>
        <img src="figs/angle_coords_1.png" width="100%"/>
        <figcaption>

        </figcaption>
    </figure>

    <p>In application, $\phi_s$ is computed at every RPS command angle to account for any polarization projection effects from the mirror<sup><a name="sup2" href="#ftn2">[2]</a></sup>:</p>


    \begin{equation}
    \label{eq:modcurve2}
    A(\zeta) = G\left(\cos\left(2\left(\zeta+\psi+\phi_s\right)\right)-\frac{\epsilon+1}{\epsilon-1}\right)\left(n_1\cos(\zeta)+n_2\sin(\zeta)+1\right)
    \end{equation}

    <p>This way, the angle we estimate from the modulation curve is automatically given as $\phi_d$.</p>

    <p>
        We estimate these parameters by minimizing the chi-squared:
    </p>

    \begin{equation}
        \chi^2 = \sum_\zeta \frac{\left(\hat{A}_\zeta-A_\zeta'\right)^2}{\sigma_\zeta^2}
    \end{equation}

    <p>
        Where for a given command angle $\zeta$, $\hat{A}$ is the amplitude of the beam fit from Eq. \ref{eq:beam}, $A'$ is the amplitude from the model given some parameters, and $\sigma$ is the uncertainty on the fit beam amplitude $\hat{A}$ given from the <tt>matmin</tt> fitting function. The priors on all five parameters are flat.
    </p>


    <p>
        From Eq. \ref{eq:modcurve2}, we can see that the uncertainty on the $\phi_d$ is sourced by the three terms $\zeta_{grav}$, $\psi$, and $\phi_s$.
        $\sigma_{\zeta}$ describes mechanical or calibration uncertainties arising from the rotation stage;
        $\sigma_{\psi}$ is driven by both sample variance in the detector timestreams and systematics involved with the coupling efficiency between the telescope and the source;
        and $\sigma_{\phi s}$ summarizes any errors propagated through the parameters input to the pointing model.
    </p>

   
    
    <p><b>Note:</b> Our mainline CMB analysis uses detector polarization angles in terms of &chi; for inputs; I present angles in terms of $\phi_d$ here because these angles are easier to interpret since detectors line up with ~0/90&deg; as opposed to &chi; which has an additional dependence on &theta;.
        Before committing these to the pipeline, these angles will converted to their final &chi;-angle values via:
    </p>

    \begin{equation}\label{eq:chiangle}
    \chi = \phi-\theta
    \end{equation}


    <h4>Pair-Difference Polarization Angles</h4>

    <p>
        It is also useful to calculate the "pair-difference" polarization angle and polarization efficiency:
<!--        In practice, the contribution of the cross-polar response to this angle is very small so the per-pair polarization angle can be approximated by:-->
<!--    </p>-->
<!--    \begin{equation}-->
<!--    \phi_{pair}\sim\frac{\phi_A+\phi_B-90}{2}-->
<!--    \end{equation}-->


    <p>We start with a Stokes vector aligned with +Q:</p>

    \begin{equation}
    S =
    \begin{bmatrix}
    I \\
    Q \\
    U \\
    \end{bmatrix}
    =
    \begin{bmatrix}
    1 \\
    1 \\
    0 \\
    \end{bmatrix}
    \end{equation}

    <p>and rotate Q into U by the per-detector polarization angle $\phi$</p>

    \begin{equation}
    S_{rot} = R(\phi)S
    \end{equation}

    <p>Where R is the rotation matrix</p>

    \begin{equation}
    R(\phi) =
    \begin{bmatrix}
    1 & 0 & 0 \\
    0 & \cos(2\phi) & -\sin(2\phi) \\
    0 & \sin(2\phi) & \cos(2\phi) \\
    \end{bmatrix}
    \end{equation}

<p>The pair-combined Stokes vector is the sum of the rotated vectors from A and B detectors as well as two additional terms to account for cross-polar response which are orthogonal to their respective A/B terms and scaled by $\epsilon$</p>

    \begin{equation}
    S_{total} = \left[R(\phi_A)+R(\phi_B+\frac{\pi}{2})+\epsilon_A R(\phi_A+\frac{\pi}{2})+ \epsilon_B R(\phi_B)\right]S
    \end{equation}

    <p>
        and the effective per-pair polarization angle $\phi_{pair}$ and polarization efficiency
     $\epsilon_{pair}$ is simply
    </p>
    \begin{equation}\label{eq:phiq}
    \begin{split}
    &\phi_{pair} = \frac{1}{2}\tan^{-1}\frac{S_3}{S_2}\\
    &\\
    &\epsilon_{pair} = \frac{\sqrt{S_2^2+S_3^2}}{S_1}
    \end{split}
    \end{equation}

<h3>RPS Observations</h3>

    <p>
        We acquire beam maps of a given detector by scanning over the RPS in 9&deg;Az&times;2&deg;El rasters at 1.5&deg;/s in Az and 0.1&deg; steps in El -- all with the RPS fixed at a given angle WRT gravity.
        We get modulation curves by completing multiple rasters over the same part of the focal plane with the RPS commanded to a different angle for each raster, which we call a rasterset.
        Each rasterset includes 13 rasters with the RPS rotated from -180&deg; to 180&deg; in 30&deg; increments and takes about 40 minutes to complete -- compare to a full Moon schedule which takes a roughly an hour.
        A typical RPS schedule run by GCP consists of 19 rastersets where the first rasterset starts with an El offset of -12.5&deg; and steps in 1.5&deg; between each rasterset to ensure there are no gaps in coverage over the focal plane [see Fig. 1.1 of <a href="JAC2022a"></a> for an example].
        In this posting, I'll typically refer to the RPS data in terms of rasters, rastersets, or observations. Each observation typically consists of 3 schedules and generally maps beams across the entire focal plane at a single DK angle.
    </p>

    <p>
        Aside from the main suite of science-grade RPS schedules, we also completed a number of cross check schedules. These schedules are mostly identical to the our main schedules except we adjust one or two parameters depending on the particular systematics we want to probe. We categorize the schedules by their schedule number where the most recent RPS science schedule is Type-5 and proceeding schedule types denote cross-check schedules<sup><a name="sup1" href="#ftn1">[1]</a></sup>. A list of the observations we collected in Jan 2022, their schedule types and their uses is shown in Table 1.1. For the 2022 observing season, we acquired 10 science-grade observations at 9 different DK angles along with ~1 full week of diagnostic observations. You can find more information on the data collected at the <a href="http://bicep.rc.fas.harvard.edu/general_projects/rps/#rps_schedule_2022">RPS Landing Page</a>.
    </p>


    <figure class="table">
        <table class="center results">
            <tr>
                <th colspan="1">Schedule Type</th>
                <th colspan="1">Obs. Length (Hrs.)</th>
                <th colspan="1">Total Time (Hrs.)</th>
                <th colspan="1">Adjusted Parameter</th>
                <th colspan="1">Systematics Probed</th>
            </tr>
            <tr>
                <td>5</td>
                <td>13.5</td>
                <td>420.4</td>
                <td>None</td>
                <td>Standard RPS Observations</td>
            </tr>
            <tr>
                <td>6</td>
                <td>13.6</td>
                <td>13.6</td>
                <td>RPS angle -180 to 180 Minus DK angle</td>
                <td>Importance of nulling mod curve</td>
            </tr>
            <tr>
                <td>7</td>
                <td>1</td>
                <td>70.7</td>
                <td>Target Moon, only one raster</td>
                <td>Standard Moon Observations</td>
            </tr>
            <tr>
                <td>8</td>
                <td>0.1</td>
                <td>0.5</td>
                <td>No Mount Movement</td>
                <td>Rotation stage operational checks</td>
            </tr>
            <tr>
                <td>9</td>
                <td>0.5</td>
                <td>22.9</td>
                <td>Quick-turnaround 1&deg;&times;1&deg; single-pair map</td>
                <td>System stability</td>
            </tr>
            <tr>
                <td>9.1</td>
                <td>0.3</td>
                <td>3.5</td>
                <td>1&deg;&times;1&deg; map, 45&deg; increments</td>
                <td>&sigma;-Angle vs. Mod Curve Samples</td>
            </tr>
            <tr>
                <td>9.2</td>
                <td>1.1</td>
                <td>11.0</td>
                <td>1&deg;&times;1&deg; map, 10&deg; increments</td>
                <td>&sigma;-Angle vs. Mod Curve Samples</td>
            </tr>
            <tr>
                <td>9.3</td>
                <td>0.5</td>
                <td>4.6</td>
                <td>1&deg;&times;1&deg; map, No Homing between obs.</td>
                <td>RPS homing precision</td>
            </tr>
            <tr>
                <td>10</td>
                <td>3.1</td>
                <td>9.2</td>
                <td>RPS fixed & boresight rotated instead</td>
                <td>Pointing model validation</td>
            </tr>
            <tr>
                <td>11</td>
                <td>3.2</td>
                <td>9.2</td>
                <td>Rasters 27&deg; in Az</td>
                <td>Short- & long-timescale mirror deformation</td>
            </tr>

        </table>
        <figcaption>

        </figcaption>
    </figure>

    <p>
        For this posting, we'll be focusing on polarization parameters derived from the standard Type-5 datasets which cover the entire focal plane.
        In section 4, we'll also look at data from Type-9 schedules which mapped only a single pair at the center of the focal plane for diagnostic purposes.
    </p>
</section>

<section><h2>Estimates of Polarization Angles and Cross-Polar Efficiency</h2>
    <p>In this sections, I show the per-detector and per-pair polarization angles angles and cross-polar efficiencies.
        <ul>
        <li>The angles are shown as $\phi_d$ which include corrections for the tilt meter and per-rasterset mirror
            tilt/roll fits but which also include the uncertainties that propagate through the rotation stage and
            pointing model as well as the modulation curve fits as discussed in the previous section.</li>

        <li>For cross-polar response estimates, I allow the parameters to go negative.
        While negative $\xpol$ isn't physical, doing so prevents the mean from being biased away from zero in the
            event that we don't have sufficient constraining power to measure it (which is the case for some
            detectors).</li>

        <li>I perform a series of statistical cuts on the data to exclude poor fits. Further, only detector pairs that are included in B18 were allowed to pass. See &sect;A.1 for more details.</li>
    </ul>
        
    <p>In the pager below, I show this year's polarization angles (in terms of $\phi$, not &chi;) and cross-polar efficiency per channel and per-observation. Because modules on MCE0 are clocked 90&deg; WRT the rest of the focal plane, I differentiate detectors based on their orientation aligning with 0&deg; or 90&deg; instead of A vs. B. Lastly, these plots only include detector pairs used in BK18.</p>

    <figure>
        <img alt="Name pager" id="channelpager" src="#" />
        <figcaption>
            Scatter plot of polarization params as a function of GCP Channel number. <b>Top/Middle:</b> Detectors are separated by their orientation along the theta=0 axis. <b>Bottom:</b> subtracted to show orthogonality in the case of $\phi$.
            The black dashed lines indicate the MCE's.
            The colors differentiate observations.
        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/'+params.val+'_vs_chan_090_2022.png';
            }

            pager.link("#channelpager",
                {
                    'Y-Axis|val' : ['phi','xpol','N1','N2','amp'],
                    //'Year|year' : ['2018','2022'],
                },
                fcn);
            pager.setparams({
                'val' : 'phi',
                //'year': '2022',
            });
        </script>
    </figure>

    <p>
        We can see that the angles are mostly the same with the largest variation being between different tiles. A particularly interesting thing to note is that we see a consistent non-orthogonality between detectors in a given pair of 0.7&deg;&pm;0.32&deg; (MCE0 is at -0.7 in Fig 2.1 because of the 90&deg; clocking of the modules).
    </p>
    <p>
        The corner plots below show the fit parameters plotted against each other to look for any strong correlations between parameters.
    </p>

    <figure>
        <img alt="Name pager" id="cornerplotpager" src="#" width=80%/>
        <figcaption>
            Corner plots of parameters estimated from Eq: \ref{eq:modcurve2}. Each dot represents an estimate per-detector which has had its median over all 10 observations subtracted. The data are colored to differentiate observations where dark blue indicates observations in early January and yellow being observations taken in late January.
        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/pol_param_corner_plots_'+params.ang+'.png';
            }

            pager.link("#cornerplotpager",
                {
                    'Det Angle|ang' : ['0','90'],

                },
                fcn);
            pager.setparams({
                'ang' : '0',

            });
        </script>
    </figure>

    <p>
        The pager below shows the per-pair estimates averaged over all 10 observations (9 Dk angles + 1 repeat).
    </p>

    <figure>
        <img alt="Name pager" id="tileplotpager" src="#" />
        <figcaption>
            Scatter plot of polarization params as a function of GCP Channel number. <b>Top/Middle-Top:</b> Detectors are separated by their orientation along the theta=0 axis. <b>Middle-Bottom:</b> subtracted to show orthogonality in the case of $\phi$. <b>Bottom:</b> "pair-difference" estimates.
            The black dashed lines indicate the MCE's.
            The colors differentiate observations.
        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/'+params.val+'_tile_plot'+params.ms+'.png';
            }

            pager.link("#tileplotpager",
                {
                    'Y-Axis|val' : ['$\\phi_{pair}$|phi','$1-\\epsilon_{pair}$|xpol'],//,'n1','n2','amp'],
                    'Med-Sub|ms' : ['Off|','On|_medsub'],
                },
                fcn);
            pager.setparams({
                'val' : 'phi',
                'ms': '',
            });
        </script>
    </figure>

    <p>
        Another thing to note is that we can see that MCE3 has only a few detectors pass cuts. For BK18, less than 100 pairs from MCE3 (compared to ~200 for the others) and only ~30% of these pass my cuts on aluminum.
    </p>

</section>

<section><h2>Consistency and Statistical Uncertainty</h2>

    <p>
        I first take a look at how this dataset compares to the RPS measurements I took back in 2018 and also how it compares to the parameters that were were used for BK18. For the BK18 phis, I just do the reverse of Eq. \ref{eq:chiangle}: $\phi = \chi + \theta_{ref}$ where $\chi$ and $\theta_{ref}$ are <tt>p.chi</tt> and <tt>p.chi_thetaref</tt> from the FP data file respectively.
    </p>


    <figure>
        <img alt="Name pager" id="channelpager2" src="#" />
        <figcaption>
            Scatter plot of polarization params as a function of GCP Channel number. <b>Top/Middle:</b> Detectors are separated by their orientation along the theta=0 axis. <b>Bottom:</b> subtracted to show orthogonality in the case of $\phi$.
            The black dashed lines indicate the MCE's.
            The colors differentiate observations.
        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/'+params.val+'_vs_chan_090_'+params.year+'.png';
            }

            pager.link("#channelpager2",
                {
                    'Y-Axis|val' : ['phi','xpol'],
                    'Year|year' : ['RPS 2018|2018','RPS 2022|2022','B18 FPU Data|exp'],
                },
                fcn);
            pager.setparams({
                'val' : 'phi',
                'year': '2022',
            });
        </script>
    </figure>

<p>We already have a qualitative confirmation that the polarization properties over the years have remained relatively unchanged (even after swapping out a window).</p>

    <p>The pager below shows direct comparisons between the 2018, and the B18 FPU 'obs' data. For 2018 vs. 2022, I compare the years per-pair where the pairs are averaged over all 4 observations for 2018 and all 10 observations for 2022. For 2022 vs. B18 FPU Data, the 2022 data is averaged over all 10 observations. For 2022 vs. 2022, I compare the averages of two subsets of 5 observations each with no repeating observations between the two sets.</p>

    <figure>
        <img alt="Name pager" id="consistpager" src="#" />
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/consistplot_'+params.val+'_2022_vs_'+params.year2+'.png';
            }

            pager.link("#consistpager",
                {
                    'Comparison|val' : ['$\\phi_{pair}$|phi','1-Poleff|xpol'],
                    'Year|year2' : ['RPS 2018|2018','B18 FPU Data|fpu','RPS 2022|2022_min'],
                },
                fcn);
            pager.setparams({
                'val' : 'phi',
                'year2': '2022_min',
            });
        </script>
    </figure>

    <p>The data between 2018 and 2022 are very consistent -- the major differences (~0.1deg shift, higher variance) can be well explained by the 2018 data having a bad tiltmeter calibration <a href="CV2021"></a>.

    </p>

    <p>For 2022 vs. B18 'Obs', we see an offset of -0.730 degrees -- this is the angle we would expect if we fit a global rotation angle to B18 right now, assuming map coverage, detector weighting, and galactic foregrounds were negligible. That said, all of these factors may affect the actual angle we see in the real data to some degree (pun intended), so it's not useful to focus too much on it.</p>

    <p>Finally for the two RPS2022 subsets of data, we can see that the data is self-consistent to within 0.027&deg;. I take this value as the upper limit of the statistical uncertainty on the angle.</p>

</section>

<section>
    <h2>Systematics</h2>
    <h3>Tilt Correction</h3>
    <p>
        When computing the polarization angles, we account for the tilt by subtracting it from the rotation stage angle at every command angle. In the image below, I show histograms of the per-pair polarization angles with the per-pair median angle subtracted so that only the scatter on the angles is presented. We can see that the tilt correction improves the standard deviation of the distribution by 0.023&deg; or ~30%.
    </p>
    <figure>
        <img src="figs/tilt_corr_hist.png" />
        <figcaption>

        </figcaption>
    </figure>


<!--    <h3>Pol Params Vs. Stuff plots</h3>-->
<!--<p>Below are plots of polarization angles <b>with the per-detector median subtracted</b>.</p>-->
<!--    <figure>-->
<!--        <img alt="Name pager" id="yvxpager" src="#" />-->
<!--        <figcaption>-->
<!--            Each dot represents a single detector aligned with either 0&deg; or 90&deg; unless the 'pair' option is selected which shows the pair-diff angle for $\phid$, 1-efficiency for $\xpol$ and the pair-average for N1, N2, and Amp. Data are colored by observation number with dark blue being the first and yellow being the last.-->
<!--        </figcaption>-->
<!--        <script type="text/javascript">-->
<!--            function fcn(params){-->
<!--                return 'figs/scatter_'+params.y+'_'+params.subset+'_vs_'+params.x+params.medsub+'.png';-->
<!--            }-->

<!--            pager.link("#yvxpager",-->
<!--                {-->
<!--                    'Y|y' : ['phi','xpol','n1','n2','amp'],-->
<!--                    '0/90/Pair|subset' : ['0','90','Pair|p'],-->
<!--                    'X|x' : ['Time|t','peak_diff','el_cen_sun'],-->
<!--                    'Median-Subtraction|medsub' : ['Off|','On|_medsub'],-->
<!--                },-->
<!--                fcn);-->
<!--            pager.setparams({-->
<!--                'y' : 'phi',-->
<!--                'subset': '0',-->
<!--                'x': 't',-->
<!--                'medsub':'_medsub',-->
<!--            });-->
<!--        </script>-->
<!--    </figure>-->

<!--    <p>Interesting Clicks:-->
<!--        <ul>-->
<!--    <li>-->
<!--        <a href="javascript:pager.setparams({'y':'phi','subset':'0','x':'t','medsub':'_medsub'})">phi 0</a>-->
<!--        vs-->
<!--        <a href="javascript:pager.setparams({'y':'phi','subset':'90','x':'t','medsub':'_medsub'})">phi 90</a>, median-subtracted:-->
<!--        There appears to be some anti-correlation in the angle estimates between detectors of a given pair. This is particularly obvious in the very first dataset collected in late December.-->
<!--    </li>-->
<!--    <li>-->
<!--        <a href="javascript:pager.setparams({'y':'n1','subset':'0','x':'peak_diff'})">N1,0</a>-->
<!--        and-->
<!--        <a href="javascript:pager.setparams({'y':'n2','subset':'90','x':'peak_diff'})">N2,90</a> vs mod curve pk-pk fractional difference:-->

<!--    </li>-->
<!--    <li>-->
<!--        <a href="javascript:pager.setparams({'y':'amp','subset':'p','x':'el_cen_sun'})">Amp,Pair</a>-->
<!--        Vs, Sun Elevation-->



<!--    </li>-->
<!--    -->
<!--</ul>-->
<!--    </p>-->


    <h3 id="abanticorr">Detector Pair Anticorrelations</h3>
    <p>If we plot the detector pairs against each other within a given rasterset, we can see anticorrelation between them which is consistent between the Standard Type 5 data and the Type 9 data across the whole campaign.</p>
    <figure>
        <img alt="Name pager" id="avbpager" src="#" />
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/pol90_vs_pol0_type'+params.type+'.png';
            }

            pager.link("#avbpager",
                {
                    'Obs Type|type': ['Type 5|5','Type 9|9'],
                },
                fcn);
            pager.setparams({
                'type' : '5',

            });
        </script>
    </figure>

    <p>In the pager below, I show the covariance and correlations as a function of DK angle. With the exception of DK=0 in the type 5's, I get a covaraince of ~-0.005&deg;<sup>2</sup> and a correlation of ~-0.6.
    </p>

    <figure>
        <img alt="Name pager" id="covcorrpager" src="#" />
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/'+params.cov+'_vs_dk.png';
            }

            pager.link("#covcorrpager",
                {
                    'Cov / Corr|cov': ['Covariance|cov','Correlation|corr'],
                },
                fcn);
            pager.setparams({
                'cov' : 'cov',

            });
        </script>
    </figure>

    <p>By definition, the slopes of the modulation curves for a Pol0 and Pol90 detector are 90&deg; out of phase which means that, for a change in angle in the mod curve, the change in amplitude for one detector would be positive and the other would be negative. Thus, we can imagine that if the signals of Pol0 and Pol90 detectors were correlated in some way, we would expect the effect on the angles to be anticorrelated.</p>

    <p>Below is a plot of the Pol 90 vs. Pol 0 mod curve fractional residuals (i.e. $\left(A_{model}-A_{data}\right)/A_{model}$) which shows that some fraction of the noise in the modulation curves is correlated. Each point is the fractional residual for one detector pair at one of 13 data points in the modulation curve. In the plot, I only show data where the amplitudes along the mod curve are equal between Pol 0 and Pol 90 -- this ensures that the uncorrelated noise in Pol0 and Pol90 are roughly equal and makes correlations easier to see.</p>

    <figure>
        <img src="figs/pol90_vs_pol0_mod_curve_res.png">
        <figcaption>

        </figcaption>
    </figure>
    
    <p>In an old posting <a href="JAC2018"></a>, I showed that RPS beam maps and modulation curves were dominated by noise that scaled with the amplitude -- likely a result from some systematic in the demodulation routine.
        Below, I show that fitting sims of mod curves with only correlated amplitude-scaling noise produces anticorrelations in detector pairs at a similar level as seen in the real data.
    </p>
    <p>I create modulation curves with known input parameters and add some white noise $N$ that is scaled by the modulation curves for both a detector with an angle of 0&deg;, $A_0$, and one with an input angle of 90&deg;, $A_{90}$.</p>

    \begin{equation}
    \begin{split}
    &\hat{A}_0 = A_0+A_0\,N\\
    &\hat{A}_{90} = A_{90}+A_{90}\,N\\
    \end{split}
    \end{equation}

    <p>
        Because I want the noise to be correlated, I use the same N for both mod curves for a given realization. I use a noise amplitude of 1.3% which I calculated from real modulation curves, though I find that changing the noise amplitude only changes the covariance while the correlation remains the same.
    </p>
    <p>I then fit my angle and 4 other parameters to each realization. Below, I plot $\phi_0$ vs $\phi_{90}$ for these sims and find a correlation of ~-0.6 which is consistent with the real data within 10%.</p>
    
    <figure>
        <img src="figs/pol90_vs_pol0_sim.png">
        <figcaption>

        </figcaption>
    </figure>

    <h3 id="phivsobs">Overall Pair Angle fluctuation per-Obs</h3>

    <p>We see fluctuations on the per-pair angle averaged over all pairs in a given observation of ~0.04&deg;.
        Because we have a ~1.5 degree spread in angle across the focal plane, a shift of O(0.04&deg;) is easy to miss unless you subtract the median angle for that pair across all observations before averaging across pairs within a single observation.</p>

    <p>The plot below shows the $\phi_{pair}$ median-subtracted per-pair and then averaged per-observation. The error bars are the 1&sigma; standard deviations of the median-subtracted distributions. </p>

    <figure>
        <img src="figs/phi_pair_vs_obs_medsub.png" width="70%">
        <figcaption>

        </figcaption>
    </figure>

    <p>The major question that needs to be answered is whether we are confident that the value these angles average down to is the right one. Perhaps it would be best to include this 0.04&deg; fluctuation in our systematic uncertainty just to be safe?</p>
    <p>So far, I have not been able to find any correlations with these offsets that would point to a particular systematic (correlating with DK angle, for instance).</p>



</section>

<hr>

<section class="appendix">
<h2 class="appendix">Appendix</h2>
    <h3>Channel Cuts</h3>

    <figure>
        <img src="figs/rps_channel_cuts.png">
        <figcaption>

        </figcaption>
    </figure>


    <figure>
        <table class="results">
            <tr>
                <th colspan="3">Channel cuts of 24016</th>
            </tr>
            <tr>
                <th>Cut Param</th>
                <th>Cut Chans</th>
                <th>% Cut</th>
                <th>Unique</th>
            </tr>
            <tr>
                <td class=''>az_cen</td>
                <td class='cstart'>867</td>
                <td class='cstart'>0.0361</td>
                <td class='cstart'>0</td>
            </tr>
            <tr>
                <td class=''>el_cen</td>
                <td class='cstart'>867</td>
                <td class='cstart'>0.0361</td>
                <td class='cstart'>0</td>
            </tr>
            <tr>
                <td class=''>xres</td>
                <td class='cstart'>2861</td>
                <td class='cstart'>0.1191</td>
                <td class='cstart'>12</td>
            </tr>
            <tr>
                <td class=''>yres</td>
                <td class='cstart'>2870</td>
                <td class='cstart'>0.1195</td>
                <td class='cstart'>5</td>
            </tr>
            <tr>
                <td class=''>xerr</td>
                <td class='cstart'>3882</td>
                <td class='cstart'>0.1616</td>
                <td class='cstart'>7</td>
            </tr>
            <tr>
                <td class=''>yerr</td>
                <td class='cstart'>3861</td>
                <td class='cstart'>0.1608</td>
                <td class='cstart'>6</td>
            </tr>
            <tr>
                <td class=''>agof</td>
                <td class='cstart'>76</td>
                <td class='cstart'>0.0032</td>
                <td class='cstart'>13</td>
            </tr>
            <tr>
                <td class=''>phi_err</td>
                <td class='cstart'>4488</td>
                <td class='cstart'>0.1869</td>
                <td class='cstart'>81</td>
            </tr>
            <tr>
                <td class=''>phi_medsub</td>
                <td class='cstart'>4433</td>
                <td class='cstart'>0.1846</td>
                <td class='cstart'>438</td>
            </tr>
            <tr>
                <td class=''>tfpu_mean</td>
                <td class='cstart'>1074</td>
                <td class='cstart'>0.0447</td>
                <td class='cstart'>0</td>
            </tr>
            <tr>
                <td class=''>tfpu_std</td>
                <td class='cstart'>1436</td>
                <td class='cstart'>0.0598</td>
                <td class='cstart'>186</td>
            </tr>
            <tr>
                <td class=''>n1</td>
                <td class='cstart'>1096</td>
                <td class='cstart'>0.0456</td>
                <td class='cstart'>14</td>
            </tr>
            <tr>
                <td class=''>n2</td>
                <td class='cstart'>999</td>
                <td class='cstart'>0.0416</td>
                <td class='cstart'>4</td>
            </tr>
            <tr>
                <td class=''>No Pair</td>
                <td class='cstart'>1971</td>
                <td class='cstart'>0.0821</td>
                <td class='cstart'>1971</td>
            </tr>
            <tr>
                <th>Total</th>
                <td class='cstart'>8248</td>
                <td class=''>0.3434</td>
                <th></th>
            </tr>
        </table>
    </figure>


    <h3>Full Y Vs. X pager</h3>
    <figure>
        <img alt="Name pager" id="yvxpager2" src="#" />
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/scatter_'+params.y2+'_'+params.subset2+'_vs_'+params.x2+params.medsub2+'.png';
            }

            pager.link("#yvxpager2",
                {
                    'Y|y2' : ['phi','xpol','n1','n2','amp'],
                    '0/90/Pair|subset2' : ['0','90','Pair|p'],
                    'X|x2' : ['Time|t','Obs. Number|obsnum','Az|az_cen','El|el_cen','DK|dk_cen',
                        'Sun Az|az_cen_sun','Sun El|el_cen_sun','x','y',
                    'xm','ym','r','theta','thetam','tilt_out','tilt_out_std','tilt_temp','tod','peak_diff'],
                    'Median-Subtraction|medsub2' : ['Off|','On|_medsub'],
                },
                fcn);
            pager.setparams({
                'y2' : 'phi',
                'subset2': '0',
                'x2': 't',
                'medsub2':'_medsub',
            });
        </script>
    </figure>

    <h3>Modulation Curve Residuals</h3>
    <figure>
        <img alt="Name pager" id="modcurvepager" src="#" />
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            function fcn(params){
                return 'figs/modcurveres_dk'+params.dk+'.png';
            }

            pager.link("#modcurvepager",
                {
                    'DK|dk' : [
                        '0', '-61|61','23','174','68_1', '-81','90','45','135','68_2',
                    ],
                },
                fcn);
            pager.setparams({
                'dk' : '0',
            });
        </script>
    </figure>

    <h3>Footnotes</h3>
    <p>Click on the number to return to the main text.</p>
    <div class="footnote">
        <p>
        </p>
        <p>
            <a name="ftn1" href="#sup1">[1]</a></sup>Example: a standard RPS schedule (type-5) at DK=0 is <tt>8_ffflat_rps_05_dk000_XXX.sch</tt> and a stability checking Type-9 schedule at DK=45 would be <tt>8_ffflat_rps_09_dk045_XXX.sch</tt> where <tt>XXX</tt> is the iteration number.
        </p>
        <p>
            <a name="ftn2" href="#sup2">[2]</a>This is strictly speaking in the geometrical sense. I plan to discuss differential reflection of polarization due to the fact that the mirror is aluminum in another posting.
    </p>

    </div>
    <h3>Code</h3>
    <p>Below is a list of code that was used for this analysis. The code is committed to the pipeline and can be found in the <tt>analysis/beammap/</tt> directory.</p>
    <p id="code"></p>

    <h3>Data</h3>
    <p id="data"></p>
    <h3>References</h3>

    <p id="references"></p>


    <p id="testp"></p>

    <script type="text/javascript">

        // Shorthand tags
        var codes = [
            //"rps_fit_mirror_from_moon.m",
            ];

        // Posting titles
        var desc = [
            //"Derives mirror parameters from observations of the moon.",
        ];

        // Make a list of references
        var post = document.getElementById("code");
        var msg = "<table class=\"code\">";
        for (var code in codes){
            msg = msg + "<tr><td><tt>"+codes[code]+"</tt></td><td> - </td><td>"+desc[code]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

    </script>

    <script type="text/javascript">

        // Shorthand tags
        var data = [
            //"moonsch.mat",
            ];

        // Posting titles
        var desc = [
            //"Metadata of Moon observations",
            ];

        // Make a list of references
        var post = document.getElementById("data");
        var msg = "<table class=\"code\">";
        for (var datum in data) {
            msg = msg + "<tr><td><tt>" + data[datum] + "</tt></td><td> - </td><td>" + desc[datum] + "</td>";
        }
        ;
        msg = msg + "</table>";
        post.innerHTML = msg;

    </script>



    <script type="text/javascript">

        // This my way of making shorthand links.
        // We'll make a couple arrays with the 'tag' and href information
        // and then look through each anchor element for the specified tag.
        // The anchors should then just look like: <a href="tagname"></a>
        // and the script will automatically fill in the hyperlings and text.


        var posting_dir = window.location.href; // What's the current url?

        var bkurl = "bicep.rc.fas.harvard.edu";
        var spurl = "bicep.usap.gov";

        // These are the possible places to find postings
        // The strings are for if you post your posting in that directory.
        var sitemap = {
            jcornelison: "../../../",   // /jcornelison/postings/
            bkcmb : "../../../../",     // /bkcmb/analysis_logbook/analysis/
            bicep3: "../../../",        //
            bicep_array: "../../../",   //
            bicep2: "",                 // We shouldn't be posting in these, but still have postings we can reference.
            keck  : "",                 // keck/analysis_logbook/analysis/
            spuder: "",                 // ~spuder/hieno_analysis_logboo
            bicep1: "",                 // ~bicep1/analysis_logbook_north/
            general_projects:"",
                   };
        // Logbook Site map:
        // personal:www/jcornelison/postings/
        // bkcmb:   www/bkcmb/analysis_logbook/analysis/
        // keck:    www/keck/analysis_logbook/analysis/
        // BICEP3:  www/bicep3/analysis_logbook/
        // BA:      www/bicep_array/analysis_logbook/
        // We shouldn't be posting in these, but still have postings.
        // bicep2:
        // keck:    www/keck/analysis_logbook/analysis/
        // spuder:  www/~spuder/hieno_analysis_logbook/
        // bicep1:  www/~bicep1/analysis_logbook_north/


        // Shorthand tags
        var tags = [
            "KWY2007",
            "CAB2012",
            "RWO2013",
            "JAC2018",
            "JBW2018a",
            "JBW2018b",
            "JAC2019",
            "JAC2021",
            "CV2021",
            "JAC2022a",
            "JAC2022b",
            "JAC2022c",
            "BS2022",
            "JAC2023",
            "JAC2023b"
        ];

        // Links
        // Truncate the link down to the www directory in which is lies if you can.
        var hrefs = [
            "general_projects/rps/pointing_article.pdf",
            "keck/analysis_logbook/analysis/20120510_beam_map_pointing/",
            "bkcmb/analysis_logbook/analysis/20130205_polofs_model/",
            "bkcmb/analysis_logbook/analysis/20180717_rps_sims/",
            "bkcmb/analysis_logbook/analysis/20181129_B2016_beamcen_yrquarters/",
            "bkcmb/analysis_logbook/analysis/20181207_B2018_beamcen/",
            "bkcmb/analysis_logbook/analysis/20190516_rps_pointing_defs/",
            "bkcmb/analysis_logbook/analysis/20210518_bmpm/",
            "bicep3/analysis_logbook/20210916_rps_calibration_plan/",
            "bicep3/analysis_logbook/20220428_mirror_analysis/",
            "bicep3/analysis_logbook/20220505_mirror_analysis_2/",
            "bicep3/analysis_logbook/20220816_mirror_analysis_3/",
            "bkcmb/analysis_logbook/analysis/20220922_B2021_beamcens/",
            "bkcmb/analysis_logbook/analysis/20230214_IPR_pol_rot_sims/",
            "bkcmb/analysis_logbook/analysis/20230214_rps_grid_cal/",
        ];


        // Posting titles
        var desc = [
            "BICEP Pointing Supplement",
            "Pointing Model for Keck Beam Maps",
            "Modeling Polarization-Dependent Beam Offsets",
            "Simulating RPS Data",
            "B2016 per-deck, per-scan direction beam centers for quarter-season data sets",
            "B2016, B2017, and B2018 CMB-derived beam center correlations",
            "Pointing Model Definitions for Polarized Beam Mapping",
            "A New Pointing Model for Beam Mapping",
            "RPS Summary and Austral Summer 2021/2022 Calibration Plan",
            "Deriving Mirror Properties from the Moon",
            "2022 Moon Analysis II: GCP Coordinate Systems and Moon Phases",
            "2022 Moon Analysis III: Moon Phase Correction and Mirror Systematics",
            "B2021 Beam Centers",
            "Isotropic Birefringence Analysis: Global Polarization Rotation Angles in B2018 sims",
            "RPS Analysis: Polarizing Wire Grid Angle Calibration",
        ];
        // Debug
        var posty = document.getElementById("testp");


        var preface = "";
        var keys = Object.keys(sitemap);
        // If we're not at pole or bicep, just post the full URL
        // If we are, go back to the www directory.
        if (posting_dir.match(new RegExp(bkurl))!=bkurl &
            posting_dir.match(new RegExp(spurl))!=spurl){
                preface = "http://" + bkurl+"/";
            }
        else {
            for (key in keys){
                if (posting_dir.match(new RegExp("/"+keys[key]+"/"))=="/"+keys[key]+"/"){
                    preface = sitemap[keys[key]];
                };
            };

        };

        // Add the prefixes we can.
        // Only add prefixes to directories in the sitemap so we don't break
        // external references.
        for (ref in hrefs) {
            for (key in keys) {

            // If there's a match, at the prefix and move on.
            if(hrefs[ref].match(new RegExp(keys[key] + "/"))==keys[key]+"/"){
                hrefs[ref] = preface+hrefs[ref];
                break;
            }
            };
        };

        // posty.innerHTML = preface;

        // Make a list of references
        var post = document.getElementById("references");
        var msg = "<table>";
        for (var tag in tags){
            msg = msg + "<tr><td><a href="+tags[tag]+"></a></td><td> - </td><td>"+desc[tag]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

        // Look through all the hyperlinks and insert the proper links to the postings
        var links = document.getElementsByTagName("A");
        for (var link in links){
            for (var tag in tags){
                if (links[link].href.endsWith(tags[tag])){
                    links[link].text = "("+tags[tag]+")";
                    links[link].href = hrefs[tag];
                    links[link].target = "_blank";
                }
            }
        }

    </script>
</section>
</body>
