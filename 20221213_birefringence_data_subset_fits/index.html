<!DOCTYPE html>

<!--suppress HtmlDeprecatedAttribute -->
<head>
    <meta charset="utf-8">
    <title>Birefringence Analysis: B2018 Sims</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Load up MathJax for math notation -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript"
            src="../mathjax/MathJax.js?config=TeX-AMS-MML_SVG">
            // src="../mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body>
<!-- Add my custom pager script -->
<script type="text/javascript" src="scripts/pager.js"></script>
<link rel="stylesheet" type="text/css" href="scripts/pager.css">

<header>
    <h1>Uniform Birefringence Analysis II: Global Polarization Rotation Angles in B2018 sim subsets</h1>

    <time datetime="2020-xx-xx" class="published updated">
        yyyy Mmm dd
    </time> â€”
    J. Cornelison
</header>

<hr>

<p>
The goal of this posting is to probe for potential biases when fitting angles in our Polarization Rotation Sims. I also look into a possible cross-check using subsets of CMB data which would help validate as-measured polarization angles.
</p>

<hr>



<section>
    <h2>Testing on Polarization Rotation Sims</h2>
    <p>
        In this section, I try replicating what I expect happened with the real data by creating Polarization Rotation sims. These are sims that use one set of polarization angles as input when making TOD sims and another set as input during mapmaking. The procedure I follow is similar to <a href="EWB2016a"></a>:
    <ol>
        <li>Create TOD sims substituting fiducial angles with RPS-measured polarization angles.</li>
        <li>Create pairmaps with our fiducial angles (the 'obs' option in <tt>get_array_info</tt>).</li>
<!--        <li>Create three sets of B2018 daughter coadded maps split into lower, middle, and upper as shown above in Figure 1.1.</li>-->
        <li>Convert to APS.</li>
        <li>Fit global rotation angle to the APS.</li>
    </ol>
    In the pager below, I show the global rotation fits for sims create with the above procedure called "B2018+RPS". From the histogram in Figure 1.1, we can likely expect the distribution of &alpha; around -0.5&deg; and with standard deviations slightly higher than "B2018-rerun" in Figure 1.3. As a sanity check, I also created another set of sims with a flat +0.5&deg; offset added to the 'obs' chi angles in Step 1 instead of RPS-derived angles -- the expectation being that the distribution would look identical to "B2018-rerun" in figure 1.1 but with a mean of 0.5&deg;
    </p>

    <figure>
        <img alt="Name pager" id="polrothistpager" src="#" onerror=this.src="figs/blank.png" width="65%"/>
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            pager.link("#polrothistpager",
                {
                    'Sim Type|sig': ['2','3','5','6','7','8'],
                    'Purification Method|pure': ['None|','Matrix|pureB_matrix_'],
                    'Simset|sernum3': ['B2018|3553','B2018+RPS|6606','B2018+0.5deg|6610'],
                },
                function(params) {
                    return 'figs/alpha_hist_'+params.sernum3+params.pure+params.sig+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': 'pureB_matrix_',
                'sernum3': '6610',
            });
        </script>
    </figure>

<p>
    
</p>

</section>
<section>
    <h2>Cross-checking RPS Polarization Angles</h2>
    <p>
        We've come up with a procedure to cross-check that the RPS-derived polarization angles without unblinding ourselves to the birefrinence angle.

        A comparison of my preliminary RPS measurements vs the polarization angles we're currently using to make maps shows a variance across the focal plane on the order of ~1&deg;.

        That means that I should be able to split our real coadded maps into subsets based on the angle we expect from our RPS-derived polarization angles and then compare the <i>difference</i> in global rotation angle among the different subsets. Since we're looking only at relative differences, we keep ourselves blind to the absolute birefringence angle. While it doesn't really give us information on the absolute angle, having a confirmation that I got the relative angles correct lends confidence that there isn't something glaringly wrong in the RPS analysis.
    </p>
    <p>
        The figure below shows how the data could be split up. In this case, I choose to split the pairs evenly into thirds where the mean difference in global rotation angle between the lower-to-middle and middle-to-upper datasets is expected to be ~0.3&deg;.
    </p>

    <figure>
        <img src="figs/hist_diffphi.png">
        <figcaption>
            Histogram
        </figcaption>
    </figure>

    <p>The limiting factor to this technique is going to be the increased uncertainty on &alpha; due to decreasing the detector count and map coverage. So before I create new sims or do anything with the real data, I want to know beforehand whether of not the data has the statistical power at these lower detector-counts/map-coverages to differente the angles. I can quickly check this by looking first at some subsets created from the 10 B2018 sims I made for my previous posting <a href="JAC2022"></a>. These sims use the same polarization angles at both the TOD-creation and mapmaking stage so the mean angles will be zero but the distribution should accurately reflect what we can expect when we try doing this on the real data or with sims with as-measured angles injected into them.
    </p>
    <p>
        The figure below shows the same pager from Fig 2.1, but now includes APS of the three data subsets. My previous posting showed that the B18 purifcation matrix still worked on the whole-year B2018 daughter sims, so I also applied it to these smaller subsets as well to see if it still works.</p>
    <figure>
        <img alt="Name pager" id="apspager2" src="#" width="65%" onerror=this.src="figs/blank.png" />
        <figcaption>
            A pager of EB/TB APS of my 10 sims compared to the 499 sims generated for B2018. The gray lines indicate one realization and the black line indicates the mean of all realizations per-ell. Note that no matrix purification was applied to just B2018, so matrix purified APS are shown for only my sims.
        </figcaption>

        <script type="text/javascript">
            pager.link("#apspager2",
                {
                    'Signal Type|sig': ['2','3','5','6','7','8'],
                    'Purification Method|pure': ['None|','Matrix|pureB_matrix_'],
                    'Simset|sernum2': ['B2018|3553','B2018-rerun|6600','subset-lower|6603','subset-middle|6604','subset-upper|6605'],
                    'y-axes|axes': ['Fixed|_fixed','Free|_free']
                },
                function(params) {
                    return 'figs/aps_'+params.sernum2+'_'+params.pure+params.sig+params.axes+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': '',
                'sernum2': '6600',
                'axes': '_fixed',
            });
        </script>
    </figure>

    <p>
        Not surprisingly, we see a slight increase in variance in the smaller B2018 subsets due to a drop in detector-count and coverage. On the plus side, we can still see that the purification matrix still appears to be working effectively.
    </p>

    <p>
        I now fit the global rotation angle to each signal type of each subset and examine the distributions.
    </p>

    <figure>
        <img alt="Name pager" id="histpager2" src="#" onerror=this.src="figs/blank.png" width="65%"/>
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            pager.link("#histpager2",
                {
                    'Sim Type|sig': ['2','3','5','6','7','8'],
                    'Purification Method|pure': ['None|','Matrix|pureB_matrix_'],
                    'Simset|sernum2': ['B2018|3553','B2018-rerun|6600','subset-lower|6603','subset-middle|6604','subset-upper|6605'],
                },
                function(params) {
                    return 'figs/alpha_hist_'+params.sernum2+params.pure+params.sig+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': '',
                'sernum2': '6600',
            });
        </script>
    </figure>

    <p>
        In the Type-8 sims, the scatter in the histograms for the subsets increases by roughly a factor of two compared to B2018-rerun. Still, since the differences in angle between each subset is at least ~0.3&deg;, we should be able to detect the differences in angle to >1-&sigma; in the real data. We can also see that the purification matrix still appears to work on these subsets, albeit to a lesser degree. All of the means are consistent with zero, so I think it's still appropriate to continue using the B18 matrix in lieu of creating new daughter matrices. I tabulate the statistics from the histograms in the figure below:
    </p>

    <figure class="table">
        <table class="results">
            <tr>
                <th></th>
                <th colspan="8">EB</th>
            </tr>
            <tr>
                <th></th>
                <th colspan="2">B2018-rerun</th>
                <th colspan="2">B2018-lower</th>
                <th colspan="2">B2018-middle</th>
                <th colspan="2">B2018-upper</th>
            </tr>
            <tr>
                <th class="cstart">Signal</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th class=>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
            </tr>
            <tr>
                <td>2</td>
                <td class='cstart'>-0.0</td>
                <td>0.00</td>
                <td class='cstart'>0.0</td>
                <td>0.01</td>
                <td class='cstart'>-0.0</td>
                <td>0.01</td>
                <td class='cstart'>-0.0</td>
                <td>0.01</td>
            </tr>
            <tr>
                <td>3</td>
                <td class='cstart'>0.0</td>
                <td>0.00</td>
                <td class='cstart'>0.0</td>
                <td>0.00</td>
                <td class='cstart'>0.0</td>
                <td>0.00</td>
                <td class='cstart'>0.0</td>
                <td>0.00</td>
            </tr>
            <tr>
                <td>5</td>
                <td class='cstart'>-0.0</td>
                <td>0.06</td>
                <td class='cstart'>-0.0</td>
                <td>0.06</td>
                <td class='cstart'>-0.0</td>
                <td>0.06</td>
                <td class='cstart'>-0.0</td>
                <td>0.06</td>
            </tr>
            <tr>
                <td>6</td>
                <td class='cstart'>0.0</td>
                <td>0.01</td>
                <td class='cstart'>-0.0</td>
                <td>0.03</td>
                <td class='cstart'>-0.0</td>
                <td>0.04</td>
                <td class='cstart'>0.0</td>
                <td>0.04</td>
            </tr>
            <tr>
                <td>7</td>
                <td class='cstart'>-0.0</td>
                <td>0.07</td>
                <td class='cstart'>-0.0</td>
                <td>0.12</td>
                <td class='cstart'>-0.0</td>
                <td>0.13</td>
                <td class='cstart'>-0.0</td>
                <td>0.13</td>
            </tr>
            <tr>
                <td>8</td>
                <td class='cstart'>-0.0</td>
                <td>0.08</td>
                <td class='cstart'>-0.0</td>
                <td>0.14</td>
                <td class='cstart'>-0.0</td>
                <td>0.14</td>
                <td class='cstart'>-0.0</td>
                <td>0.14</td>
            </tr>
        </table>
        <figcaption>

        </figcaption>
    </figure>

    <p>
        Before we try this on the real data, my next step is to attempt this on sims with preliminary RPS angles used during TOD creation.
    </p>
</section>
<section><h2>Conclusions</h2>

</section>

<hr>

<section class="appendix">
<h2 class="appendix">Appendix</h2>
    <figure>
        <img alt="Name pager" id="coveragepager" src="#" onerror=this.src="figs/blank.png" width="65%"/>
        <figcaption>
            Focal plane coverage for each of the simsets. Yellow indicates detector pairs used in the coadds.
        </figcaption>
        <script type="text/javascript">
            pager.link("#coveragepager",
                {
                    'Simset|sernum4': ['B2018-rerun|6600','subset-lower|6603','subset-middle|6604','subset-upper|6605'],
                },
                function(params) {
                    return 'figs/'+params.sernum4+'_tile_plot.png';
                });
            pager.setparams({
                'sernum4': '6600',
            });
        </script>
    </figure>


    <h3>Footnotes</h3>
    <p>Click on the number to return to the main text.</p>
    <div class="footnote">
        <p>
        <sup><a name="ftn1" href="#sup1">[1]</a></sup>

    </p>
    </div>
    <h3>Code</h3>
    <p>Below is a list of code that was used for this analysis. The code is committed to the pipeline and can be found in the <tt>analysis/beammap/</tt> directory.</p>
    <p id="code"></p>

    <h3>Data</h3>
    <p id="data"></p>
    <h3>References</h3>

    <p id="references"></p>


    <p id="testp"></p>

    <script type="text/javascript">

        // Shorthand tags
        var codes = [
            "dummycode.m",
            ];

        // Posting titles
        var desc = [
            "dummy description",
        ];

        // Make a list of references
        var post = document.getElementById("code");
        var msg = "<table class=\"code\">";
        for (var code in codes){
            msg = msg + "<tr><td><tt>"+codes[code]+"</tt></td><td> - </td><td>"+desc[code]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

    </script>

    <script type="text/javascript">

        // Shorthand tags
        var data = [
            "dummydata.mat",
            ];

        // Posting titles
        var desc = [
            "Dummy description",
            ];

        // Make a list of references
        var post = document.getElementById("data");
        var msg = "<table class=\"code\">";
        for (var datum in data) {
            msg = msg + "<tr><td><tt>" + data[datum] + "</tt></td><td> - </td><td>" + desc[datum] + "</td>";
        }
        ;
        msg = msg + "</table>";
        post.innerHTML = msg;

    </script>



    <script type="text/javascript">

        // This my way of making shorthand links.
        // We'll make a couple arrays with the 'tag' and href information
        // and then look through each anchor element for the specified tag.
        // The anchors should then just look like: <a href="tagname"></a>
        // and the script will automatically fill in the hyperlings and text.


        var posting_dir = window.location.href; // What's the current url?

        var bkurl = "bicep.rc.fas.harvard.edu";
        var spurl = "bicep.usap.gov";

        // These are the possible places to find postings
        // The strings are for if you post your posting in that directory.
        var sitemap = {
            jcornelison: "../../../",   // /jcornelison/postings/
            bkcmb : "../../../../",     // /bkcmb/analysis_logbook/analysis/
            bicep3: "../../../",        //
            bicep_array: "../../../",   //
            bicep2: "",                 // We shouldn't be posting in these, but still have postings we can reference.
            keck  : "",                 // keck/analysis_logbook/analysis/
            spuder: "",                 // ~spuder/hieno_analysis_logboo
            bicep1: "",                 // ~bicep1/analysis_logbook_north/
            general_projects:"",
                   };
        // Logbook Site map:
        // personal:www/jcornelison/postings/
        // bkcmb:   www/bkcmb/analysis_logbook/analysis/
        // keck:    www/keck/analysis_logbook/analysis/
        // BICEP3:  www/bicep3/analysis_logbook/
        // BA:      www/bicep_array/analysis_logbook/
        // We shouldn't be posting in these, but still have postings.
        // bicep2:
        // keck:    www/keck/analysis_logbook/analysis/
        // spuder:  www/~spuder/hieno_analysis_logbook/
        // bicep1:  www/~bicep1/analysis_logbook_north/

        // Shorthand tags
        var tags = [
            "JBW2016",
            "EWB2016a",
            "EWB2016b",
            "JAC2022",
        ];

        // Links
        // Truncate the link down to the www directory in which it lies if you can.
        // This ensures that we can view the linked postings at Pole without the internet.
        var hrefs = [
            "bkcmb/analysis_logbook/analysis/20160907_polrot/",
            "bkcmb/analysis_logbook/analysis/20161103_polrotsims_pager/",
            "bkcmb/analysis_logbook/analysis/20161215_rot_sims_polrot/",
            "bkcmb/analysis_logbook/analysis/20221213_birefringence_fits_to_B2018/index.html",

        ];


        // Posting titles
        var desc = [
            "Birefringence/Polarization rotation in K2015 and BK15",
            "Polarization Rotation Sims Pager",
            "Polarization Rotation Sims Global Rotation",
            "Uniform Birefringence Analysis I: Global Polarization Rotation Fits on Standard B2018 Sims",
        ];
        // Debug
        var posty = document.getElementById("testp");


        var preface = "";
        var keys = Object.keys(sitemap);
        // If we're not at pole or bicep, just post the full URL
        // If we are, go back to the www directory.
        if (posting_dir.match(new RegExp(bkurl))!=bkurl &
            posting_dir.match(new RegExp(spurl))!=spurl){
                preface = "http://" + bkurl+"/";
            }
        else {
            for (key in keys){
                if (posting_dir.match(new RegExp("/"+keys[key]+"/"))=="/"+keys[key]+"/"){
                    preface = sitemap[keys[key]];
                };
            };

        };

        // Add the prefixes we can.
        // Only add prefixes to directories in the sitemap so we don't break
        // external references.
        for (ref in hrefs) {
            for (key in keys) {

            // If there's a match, at the prefix and move on.
            if(hrefs[ref].match(new RegExp(keys[key] + "/"))==keys[key]+"/"){
                hrefs[ref] = preface+hrefs[ref];
                break;
            }
            };
        };

        // posty.innerHTML = preface;

        // Make a list of references
        var post = document.getElementById("references");
        var msg = "<table>";
        for (var tag in tags){
            msg = msg + "<tr><td><a href="+tags[tag]+"></a></td><td> - </td><td>"+desc[tag]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

        // Look through all the hyperlinks and insert the proper links to the postings
        var links = document.getElementsByTagName("A");
        for (var link in links){
            for (var tag in tags){
                if (links[link].href.endsWith(tags[tag])){
                    links[link].text = "("+tags[tag]+")";
                    links[link].href = hrefs[tag];
                    links[link].target = "_blank";
                }
            }
        }

    </script>
</section>
</body>
