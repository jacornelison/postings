<!DOCTYPE html>

<!--suppress HtmlDeprecatedAttribute -->
<head>
    <meta charset="utf-8">
    <title>Birefringence Analysis: B2018 Sims</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Load up MathJax for math notation -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript"
            src="../mathjax/MathJax.js?config=TeX-AMS-MML_SVG">
            // src="../mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body>
<!-- Add my custom pager script -->
<script type="text/javascript" src="scripts/pager.js"></script>
<link rel="stylesheet" type="text/css" href="scripts/pager.css">

<header>
    <h1>Uniform Birefringence Analysis I: Global Polarization Rotation Fits on Standard B2018 Sims</h1>

    <time datetime="2022-12-13" class="published updated">
        2022 Dec 13
    </time> â€”
    J. Cornelison
</header>

<hr>

<p>
    This posting is the first of a series which will ultimately lead to the report of constraints on Uniform Cosmic Birefringence. In this posting I probe for systematics in our pipeline function <tt>reduc_global_rotation</tt> by estimating angles from standard B2018 sim with a known rotation angle of 0&deg;. I also validate my knowledge of the simulation production pipeline by comparing an ensemble of 10 sims I made from B2018 data to the 499 B2018 sims created for the BK18 analysis.
</p>

<hr>

<section><h2>Introduction</h2>
    <p>
        The ultimate goal of this analysis is to report on a constraint of Uniform Cosmic Birefringence using the combination of our BICEP3 B18 3-year dataset on conjunction with the RPS-based polarization calibration I performed over January 2022. This is different from previous recent analyses that explore spatial or temporal birefringence -- i.e. this is a constraint on the monopole or DC birefringence signal.
    </p>
    <p>
        The fundamental procedure is fairly straightforward:
    <ol>
        <li>Measure the per-detector polarization angle & cross-polar response WRT to gravity using an external calibrator.</li>
        <li>Relate as-measured polarization angles WRT to the overall rotation of the focal plane via a pointing model (i.e. compute the &chi;-angle).</li>
        <li>Recreate our real CMB maps using as-measured &chi;-angles.</li>
        <li>Fit for an overall polarization rotation angle, &alpha;, via EB/TB minimization (AKA global polarization rotation fits, or self-calibration) -- for more details see <a href="JBW2016"></a><sup><a name="sup1" href="#ftn1">[1]</a></sup>.</li>
        <li>Any significantly non-zero alpha is possible signal of Cosmic Birefringence or, in the event of a non-detection, we use the uncertainties to report an upper limit.</li>

    </ol>

    </p>

    <p>
        There are, however, a lot of nuances at each step that need to be considered in order to convince ourselves that our results are not biased in any way. This posting focuses on Step 4 in the procedure above, particularly in answering the following questions:
    <ol type="A">
        <li>Does the global rotation fitting function impart a bias on &alpha;?</li>
        <li>What is the expected statistical uncertainty on &alpha;?</li>
        <li>Can we still accurately capture the statistics on &alpha; with fewer than 499 sims?</li>
        <li>What happens when we use our B18 Purification matrix on smaller subsets of data?</li>
    </ol>
    To that end, the rest of this posting examines the result of fitting &alpha; to B2018 sims which have no rotation angle injected.
    </p>
</section>

<section><h2>Global Polarization Rotation fits to B2018 Sims</h2>
    <p>I use two independent simsets in this analysis:
        <ul>
        <li><b>B2018</b> - the ensemble of 499 B2018 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: h)</li>
        <li><b>B2018-rerun</b> - An ensemble of 10 B2018 sims I ran myself using the same inputs as B2018 to ensure I have sufficient knowledge over how the pipeline works (sernum: 6600, daughter: h).</li>
    </ul>

    <p>
        The pager below shows EB/TB angular power spectra (APS) for both B2018 (sernum 3553) and my sims (sernum 6600) where I visually compare the means. To see if can still work for smaller subsets of data, I also apply the B18 purification matrix -- which was created from the combined B2016, B2017, and B2018 -- to my 10 sims.
</p>
    <p>
        Sim types:
        <ol start="2">

        <li>Unlensed &Lambda;CDM</li>
        <li>Gaussian Dust</li>
        <li>Unlensed &Lambda;CDM + r=0.1</li>
        <li>Lensed &Lambda;CDM</li>
        <li>Sign-flip noise</li>
        <li>Lensed &Lambda;CDM+Noise [Type 5+6]</li>
        <li>Lensed &Lambda;CDM+Noise+Dust [Type 7+3]</li>
    </ol>
    </p>

    <figure>
        <img alt="Name pager" id="apspager" src="#" width="65%" onerror=this.src="figs/blank_6x6.png" />
        <figcaption>
            A pager of EB/TB APS of my 10 sims compared to the 499 sims generated for B2018. The gray lines indicate one realization and the black line indicates the mean of all realizations per-ell.
        </figcaption>
        <script type="text/javascript">
            pager.link("#apspager",
                {
                    'Sim Type|sig': ['2','3','5','6','7','8'],
                    'Purification Method|pure': ['None|','Matrix|pureB_matrix_'],
                    'Simset|sernum': ['B2018|6614','B2018-rerun|6600'],
                    'y-axes|axes': ['Fixed|_fixed','Free|_free']
                },
                function(params) {
                    return 'figs/aps_'+params.sernum+'_'+params.pure+params.sig+params.axes+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': '',
                'sernum': '6600',
                'axes': '_fixed',
            });
        </script>
    </figure>
<p>
    Switching between the two simsets for any signal-type, we can see that my reproduction was successful. We can also see qualitatively that the purification matrix does a great job of reducing E-to-B leakage.
</p>


    <h3>Global Rotation Angle</h3>
    <p>
        Now I perform the global rotation fits on each of the sims.
    </p>
    <p>
        I estimate &alpha; for each individual sim following the procedure outlined by Eric Bullock in <a href="EWB2016"></a>:
        <ol>
        <li>Load in a real final file and sim APS.</li>
        <li>Apply the suppression factor from the real data to the sim APS.</li>
        <li>Swap the real APS for the sim APS in the final file.</li>
        <li>Pass the final file through <tt>reduc_global_rotation</tt> to fit for the angle.</li>
    </ol>
        This method ensures that each simmed APS has the same suppression factor and bandpower window function (BPWF) applied as the real data and also that the fit is properly normalized by the bandpower covariance matrix (BPCM).
    </p>
    <p>

    </p>
    <figure>
        <img alt="Name pager" id="histpager" src="#" onerror=this.src="figs/blank_6x4.png" width="85%"/>
        <figcaption>
            Example pager
        </figcaption>
        <script type="text/javascript">
            pager.link("#histpager",
                {
                    'Sim Type|sig': ['2','3','5','6','7','8'],
                    'Purification Method|pure2': ['None|','Matrix|matrix_'],
                    'Simset|sernum': ['B2018|6614','B2018-rerun|6600'],
                },
                function(params) {
                    return 'figs/alpha_hist_'+params.sernum+params.pure2+params.sig+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure2': '',
                'sernum': '6600',
            });
        </script>
    </figure>
<p>
    It's pretty easy just to confirm from the histograms that the means are all consistent with zero; the 1-&sigma; STD's between the B2018 standard and my rerun are consistent; and matrix purification still does a good job of reducing E-to-B leakage from mode-mixing despite using only a subset of the original data. Still, I create some tables below to give a more quantitative look.
</p>

    <h4>
        Fractional uncertainty when going from 499 to 10 sims
    </h4>
    <p>The uncertainty on the standard error when drawing N samples from a parent distribution with width &sigma; is:</p>

    \begin{equation*}
    \sigma_{SE} = \frac{\sigma}{\sqrt{2N-2}}
    \end{equation*}

    <p>So the fractional uncertainty when going from 499 to 10 sims is </p>

    \begin{equation*}
    \sqrt{\frac{N_2-1}{N_2-1}}\,=\,\sqrt{\frac{9}{498}}\sim13\%
    \end{equation*}


    <p>
In table 2.1, I compare the mean and 1-&sigma; standard deviations for the alphas fit from EB between the standard 499 B2018 and my 10 sims (with no purification). We should expect the standard deviations on B2018-rerun to fluctuate around &pm;13% of B2018 -- but it doesn't look like that's the case here.
</p>
    <figure class="table">
        <table class="results">
            <tr>
                <th></th>
                <th colspan="4">EB</th>
                <th colspan="4">TB</th>
                <th colspan="4">EB+TB</th>
            </tr>
            <tr>
                <th></th>
                <th class="cstart" colspan="2">B2018</th>
                <th class="cend" colspan="2">B2018-rerun</th>
                <th class="cstart" colspan="2">B2018</th>
                <th class="cend" colspan="2">B2018-rerun</th>
                <th class="cstart" colspan="2">B2018</th>
                <th class="cend" colspan="2">B2018-rerun</th>
            </tr>
            <tr>
                <th class="cstart">Signal</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th class="cend">STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th class="cend">STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th class="cend">STD (&deg;)</th>
            </tr>
            <tr>
                <td>2</td>
                <td class='cstart'>-0.00</td>
                <td>0.00</td>
                <td class='cstart'>-0.00</td>
                <td>0.00</td>
                <td class='cstart'>-0.00</td>
                <td>0.01</td>
                <td class='cstart'>-0.00</td>
                <td>0.01</td>
                <td class='cstart'>-0.00</td>
                <td>0.00</td>
                <td class='cstart'>-0.00</td>
                <td>0.00</td>
            </tr>
            <tr>
                <td>3</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
            </tr>
            <tr>
                <td>5</td>
                <td class='cstart'>-0.01</td>
                <td>0.05</td>
                <td class='cstart'>-0.00</td>
                <td>0.06</td>
                <td class='cstart'>-0.01</td>
                <td>0.09</td>
                <td class='cstart'>0.01</td>
                <td>0.10</td>
                <td class='cstart'>-0.01</td>
                <td>0.05</td>
                <td class='cstart'>-0.00</td>
                <td>0.06</td>
            </tr>
            <tr>
                <td>6</td>
                <td class='cstart'>-0.00</td>
                <td>0.01</td>
                <td class='cstart'>0.00</td>
                <td>0.01</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>0.00</td>
                <td>0.00</td>
                <td class='cstart'>-0.00</td>
                <td>0.01</td>
                <td class='cstart'>0.00</td>
                <td>0.01</td>
            </tr>
            <tr>
                <td>7</td>
                <td class='cstart'>-0.01</td>
                <td>0.10</td>
                <td class='cstart'>-0.01</td>
                <td>0.07</td>
                <td class='cstart'>-0.02</td>
                <td>0.18</td>
                <td class='cstart'>-0.05</td>
                <td>0.15</td>
                <td class='cstart'>-0.01</td>
                <td>0.11</td>
                <td class='cstart'>-0.02</td>
                <td>0.07</td>
            </tr>
            <tr>
                <td>8</td>
                <td class='cstart'>-0.01</td>
                <td>0.10</td>
                <td class='cstart'>-0.01</td>
                <td>0.08</td>
                <td class='cstart'>-0.02</td>
                <td>0.19</td>
                <td class='cstart'>-0.05</td>
                <td>0.16</td>
                <td class='cstart'>-0.01</td>
                <td>0.11</td>
                <td class='cstart'>-0.02</td>
                <td>0.08</td>
            </tr>
        </table>
        <figcaption>

        </figcaption>
    </figure>

    <h4>Scaling relation between BB power and std on Alpha</h4>
    Prove to yourself that BB power add linearly:
    <figure>
        <img src="figs/bb_power_compare_567.png"/>
    </figure>
    <figure>
        <img src="figs/bb_power_compare_35678.png"/>
    </figure>

    <p>
        And this is where understanding how the bandpower weighting affects alpha. Going from type 5 to type 7 (adding noise): Type 5 alpha is 51% of type 7.
    </p>

    <figure>
        <img src="figs/bb_power_ratio_57.png"/>
    </figure>
    <p>Going from 7 to 8 (addiing dust): Type 7 is 99% of type8.</p>
    <figure>
        <img src="figs/bb_power_ratio_78.png"/>
    </figure>

    <!--
<p>
In Table 2.2, I look at the effect of matrix purification. Once again only showing EB, I show my 10 sims with and without matrix purification for each sim type. I find that using the purification matrix reduced the variance on &alpha; at least a factor of 1.5.
</p>

    <figure class="table">
        <table class="results">
            <tr>
                <th></th>
                <th colspan="4">B2018-rerun</th>
            </tr>
            <tr>
                <th></th>
                <th colspan="2">No Pure</th>
                <th colspan="2">Matrix</th>
            </tr>
            <tr>
                <th class="cstart">Signal</th>
                <th class="cstart">Mean (&deg;)</th>
                <th>STD (&deg;)</th>
                <th class="cstart">Mean (&deg;)</th>
                <th class="cend">STD (&deg;)</th>
            </tr>
            <tr>
                <td>2</td>
                <td class='cstart'>0.0</td>
                <td>0.09</td>
                <td class='cstart'>-0.0</td>
                <td>0.00</td>
            </tr>
            <tr>
                <td>3</td>
                <td class='cstart'>0.0</td>
                <td>0.00</td>
                <td class='cstart'>0.0</td>
                <td>0.00</td>
            </tr>
            <tr>
                <td>5</td>
                <td class='cstart'>-0.0</td>
                <td>0.11</td>
                <td class='cstart'>-0.0</td>
                <td>0.06</td>
            </tr>
            <tr>
                <td>6</td>
                <td class='cstart'>0.0</td>
                <td>0.01</td>
                <td class='cstart'>0.0</td>
                <td>0.01</td>
            </tr>
            <tr>
                <td>7</td>
                <td class='cstart'>-0.0</td>
                <td>0.12</td>
                <td class='cstart'>-0.0</td>
                <td>0.07</td>
            </tr>
            <tr>
                <td>8</td>
                <td class='cstart'>-0.0</td>
                <td>0.13</td>
                <td class='cstart'>-0.0</td>
                <td>0.08</td>
            </tr>
        </table>
        <figcaption>

        </figcaption>
    </figure>
-->

</section>
<section><h2>Conclusions</h2>
    <p>
        By fitting rotation angles to our standard suite of sims, we now have answers to the questions we asked in &sect;1:
    <ol type="A">
        <li>Does the global rotation fitting function impart a bias on &alpha;?</li>
        <ul><li>No, all angles are consistent with zero.</li></ul>
        <li>What is the expected statistical uncertainties on &alpha;?</li>
        <ul><li>I quote the baseline statistical uncertainty from the 1-&sigma; standard deviation of the matrix-purified Lensed-LCDM+Noise+Dust distribution: 0.08&deg;.</li></ul>
        <li>Can we accurately capture the statistics on &alpha; with fewer than 499 sims?</li>
        <ul><li>Yes, the difference between the 499 sims and 10 is, at most, ~0.01&deg; which is satisfactory.</li></ul>
        <li>What happens when we use our B18 Purification matrix on smaller subsets of data?</li>
        <ul><li>The variance on &alpha; decreases by at least a factor of 1.5 without any apparent negative side-effects.</li></ul>
    </ol>
    </p>
    <h3>Next Steps</h3>
    <p>
        An immediate follow-up to this posting will be exploring the ability of low-N simsets to perform independent cross-checks of RPS-derived polarization angles.
    </p>
</section>

<hr>

<section class="appendix">
<h2 class="appendix">Appendix</h2>
    <h3>Footnotes</h3>
    <p>Click on the number to return to the main text.</p>
    <div class="footnote">
        <p>
        <sup><a name="ftn1" href="#sup1">[1]</a></sup>
        A more recent global rotation posting for BK18 exists, but to remain blind in this analysis I have not looked at it and do not link it here.
    </p>
    </div>
    <h3>Code</h3>
    <p>Below is a list of code that was used for this analysis. The code is committed to the pipeline and can be found in the <tt>analysis/beammap/</tt> directory.</p>
    <p id="code"></p>

    <h3>Data</h3>
    <p id="data"></p>
    <h3>References</h3>

    <p id="references"></p>


    <p id="testp"></p>

    <script type="text/javascript">

        // Shorthand tags
        var codes = [
            "rps_fit_mirror_from_moon.m",
            ];

        // Posting titles
        var desc = [
            "Derives mirror parameters from observations of the moon.",
        ];

        // Make a list of references
        var post = document.getElementById("code");
        var msg = "<table class=\"code\">";
        for (var code in codes){
            msg = msg + "<tr><td><tt>"+codes[code]+"</tt></td><td> - </td><td>"+desc[code]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

    </script>

    <script type="text/javascript">

        // Shorthand tags
        var data = [
            "moonsch.mat",
            ];

        // Posting titles
        var desc = [
            "Metadata of Moon observations",
            ];

        // Make a list of references
        var post = document.getElementById("data");
        var msg = "<table class=\"code\">";
        for (var datum in data) {
            msg = msg + "<tr><td><tt>" + data[datum] + "</tt></td><td> - </td><td>" + desc[datum] + "</td>";
        }
        ;
        msg = msg + "</table>";
        post.innerHTML = msg;

    </script>



    <script type="text/javascript">

        // This my way of making shorthand links.
        // We'll make a couple arrays with the 'tag' and href information
        // and then look through each anchor element for the specified tag.
        // The anchors should then just look like: <a href="tagname"></a>
        // and the script will automatically fill in the hyperlings and text.


        var posting_dir = window.location.href; // What's the current url?

        var bkurl = "bicep.rc.fas.harvard.edu";
        var spurl = "bicep.usap.gov";

        // These are the possible places to find postings
        // The strings are for if you post your posting in that directory.
        var sitemap = {
            jcornelison: "../../../",   // /jcornelison/postings/
            bkcmb : "../../../../",     // /bkcmb/analysis_logbook/analysis/
            bicep3: "../../../",        //
            bicep_array: "../../../",   //
            bicep2: "",                 // We shouldn't be posting in these, but still have postings we can reference.
            keck  : "",                 // keck/analysis_logbook/analysis/
            spuder: "",                 // ~spuder/hieno_analysis_logboo
            bicep1: "",                 // ~bicep1/analysis_logbook_north/
            general_projects:"",
                   };
        // Logbook Site map:
        // personal:www/jcornelison/postings/
        // bkcmb:   www/bkcmb/analysis_logbook/analysis/
        // keck:    www/keck/analysis_logbook/analysis/
        // BICEP3:  www/bicep3/analysis_logbook/
        // BA:      www/bicep_array/analysis_logbook/
        // We shouldn't be posting in these, but still have postings.
        // bicep2:
        // keck:    www/keck/analysis_logbook/analysis/
        // spuder:  www/~spuder/hieno_analysis_logbook/
        // bicep1:  www/~bicep1/analysis_logbook_north/

        // Shorthand tags
        var tags = [
            "JBW2016",
            "EWB2016",
        ];

        // Links
        // Truncate the link down to the www directory in which it lies if you can.
        // This ensures that we can view the linked postings at Pole without the internet.
        var hrefs = [
            "bkcmb/analysis_logbook/analysis/20160907_polrot/",
            "bkcmb/analysis_logbook/analysis/20161215_rot_sims_polrot/",

        ];


        // Posting titles
        var desc = [
            "Birefringence/Polarization rotation in K2015 and BK15",
            "Polarization Rotation Sims Global Rotation",
        ];
        // Debug
        var posty = document.getElementById("testp");


        var preface = "";
        var keys = Object.keys(sitemap);
        // If we're not at pole or bicep, just post the full URL
        // If we are, go back to the www directory.
        if (posting_dir.match(new RegExp(bkurl))!=bkurl &
            posting_dir.match(new RegExp(spurl))!=spurl){
                preface = "http://" + bkurl+"/";
            }
        else {
            for (key in keys){
                if (posting_dir.match(new RegExp("/"+keys[key]+"/"))=="/"+keys[key]+"/"){
                    preface = sitemap[keys[key]];
                };
            };

        };

        // Add the prefixes we can.
        // Only add prefixes to directories in the sitemap so we don't break
        // external references.
        for (ref in hrefs) {
            for (key in keys) {

            // If there's a match, at the prefix and move on.
            if(hrefs[ref].match(new RegExp(keys[key] + "/"))==keys[key]+"/"){
                hrefs[ref] = preface+hrefs[ref];
                break;
            }
            };
        };

        // posty.innerHTML = preface;

        // Make a list of references
        var post = document.getElementById("references");
        var msg = "<table>";
        for (var tag in tags){
            msg = msg + "<tr><td><a href="+tags[tag]+"></a></td><td> - </td><td>"+desc[tag]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

        // Look through all the hyperlinks and insert the proper links to the postings
        var links = document.getElementsByTagName("A");
        for (var link in links){
            for (var tag in tags){
                if (links[link].href.endsWith(tags[tag])){
                    links[link].text = "("+tags[tag]+")";
                    links[link].href = hrefs[tag];
                    links[link].target = "_blank";
                }
            }
        }

    </script>
</section>
</body>
