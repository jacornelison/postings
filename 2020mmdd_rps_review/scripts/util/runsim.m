function runsim(nbase,daughter,mapopt,sig,noise,type,sigmapfilename,rlz,tags,subsim,rlzchunksize,onlymissing,joblimit,maketod,excludehosts,dofarm,queue,ss,memusg,tagchunksize,usecompiled,maxtime,submit)
% runsim(nbase,mapopt,sig,noise,type,cigmapfilename,rlz,tags,subsim,rlzchunksize,onlymissing,joblimit,maketod,excludehosts,dofarm,queue,setrandseed,memusg,tagchunksize,usecompiled)
%
% Read in simrunfile generated by par_make_simrunfiles and launch sim jobs.
%
% nbase - first four digits of sim serial number (not set by default)
% mapopt - may be a cell array of mapopt structures, in which case a map is made for each
%          mapopt. mapopt.sernum is ignored.
% sig - simopt.sig option, i.e. 'normal' or 'none' (not set by default)
% noise - simopt.noise option, i.e. 'data' or 'none' (not set by default)
% type - last digit of sim serial number; 
%        typically 1 for signal only and 2 for noise only (not set by default)
% sigmapfilename - signal map to be used 
%       (i.e. 'input_maps/camb_planck2013_r0_noscal/map_unlens_n2048_rxxxx_sB2bbns_dNoNoi.fits')
% rlz - vector of realizations to farm, i.e. 1:10 or [1,2,10] (not set by default)
% tags - cell array of tags to simulate (not set by default)
% subsim - is this a flavour subsim? default (false)
% rlzchunksize - scalar specifying how many realizations to farm in one job
%                (default 20)
% onlymissing - if 0, farm all tags/realizations (default)
%               if 1, farm only those tags/realizations missing the proper pairmaps
%               if 2, print number of missing pairmaps but do not submit them
% joblimit - sets max number of jobs that will run at once, though can easily be changed
%            later with bgmod (default 20)
% maketod - sets simopt.maketod. (default 0) If maketod=1, read in the existing
%           pairmap simopt to set the random number generator. This means that when
%           saving TODs, the pairmaps must already exist.
% excludehosts - string or cell array of hostnames on which jobs will not be run
% dofarm - if 1 farm sims (default); if 0, execute sim in current session (for
%            testing)
% queue - default 'short_serial'
% setrandseed - 0 (default) or 1; if 1, read in existing pairmap and use the same random seed for the
%               sim; currently does not work if tagchunksize>1
% memusg - extend the minimum required memory away from default
% tagchunksize - (default 1) number of tags to farm per relization. Farming multiple
%                realizations per tag is far more efficient than farming multiple tags
%                per realization, as the pipeline has been coded with this in
%                mind. However, in cases where many tags are being simulated but only
%                one (or a few) realizations, farming multiple tags per realization
%                keeps the number of jobs low.
%
% usecompiled - 0 (default) or 1; if 1, use the compiled executable of reduc_makesim
%              instead of reduc_makesim.m 
%
% maxtime - maximum wall time, if empty (default) maximum of the queue
% 
% submit - submit to farmit or create a farmfile (default on)
%
% ex. mapopt{1}.weight=2;
%     mapopt{2}.weight=3;
% 
%     simopt.maketod=0;
%     sigmapfilename='input_maps/camb_wmap5yr_noB/map_cmb_n0512_rxxxx_s31p00.fits';
%     simopt.rndeps=[0,1;0,1];
%
%     tags=get_tags('cmb2011');
%
%     nbase=1205;
%     rlz=[1,2,10];
%
%     for i=1:numel(mapopt)
%       mapopt0=mapopt{i};
%       mapopt0.sernum=sprintf('%04dreal',nbase);
%       farm_makepairmaps(tags,mapopt0);
%     end
%     babysitsims(nbase,'resubmit');
%
%     par_make_simrunfiles(tags,simopt,nbase);
%
%     runsim(nbase,mapopt,'normal','none',1,sigmapfilename,rlz,tags);
%     runsim(nbase,mapopt,'none','data',2,sigmapfilename,rlz,tags);
%     babysitsims(nbase,'resubmit');
%
%     % make noise TOD for one realization and one tag
%     rlz=10;
%     tags=tags(1);
%     runsim(nbase,mapopt,'none','data',2,sigmapfilename,rlz,tags);

% Set defaults
if ~exist('maxtime','var')
  maxtime=[];
end
if ~exist('submit','var')
  submit=true;
end 
if ~exist('usecompiled','var')
  usecompiled=[];
end
if isempty(usecompiled)
  usecompiled=false;
end
if ~exist('subsim','var')
  subsim=[];
end
if isempty(subsim)
  subsim=false;
end
if ~exist('rlzchunksize','var')
  rlzchunksize=[];
end
if isempty(rlzchunksize)
  rlzchunksize=20;
end
if ~exist('tagchunksize','var')
  tagchunksize=[];
end
if isempty(tagchunksize)
  tagchunksize=1;
end
if ~exist('onlymissing','var')
  onlymissing=[];
end
if isempty(onlymissing)
  onlymissing=false;
end
if ~exist('joblimit','var')
  joblimit=[];
end
if isempty(joblimit)
  joblimit=20;
end
if ~exist('maketod','var')
  maketod=[];
end
if isempty(maketod)
  maketod=0;
end
if ~exist('excludehosts','var')
  excludehosts=[];
end
if isempty(excludehosts)
  excludehosts={};
end
if isstr(excludehosts)
  excludehosts={excludehosts};
end
if ~exist('dofarm','var')
  dofarm=[];
end
if isempty(dofarm)
  dofarm=1;
end
if ~exist('queue','var')
  queue=[];
end
if isempty(queue)
  queue='short_serial';
end
if ~exist('memusg','var')
  memusg=[];
end
if isempty(memusg)
  experiment=get_experiment_name;
  switch experiment
  case 'bicep2'
    memusg=10000;
  case 'keck'
    memusg=30000;
  end
end
if ~exist('ss','var')
  ss=[];
end
if isempty(ss)
  ss=false;
end


if rlzchunksize>1 & tagchunksize>1
  error('rlzchunksize and tagchunksize cannot both be >1');
end

% load the dither parameters, simopt, and mapopt
load(sprintf(['simrunfiles/%04d_',daughter,'_dithers.mat'],nbase));

% set the simulated map to use:
simopt.sigmapfilename=sigmapfilename;

% set the subsim flag:
simopt.subsim=subsim;

% Override TOD saving
simopt.maketod=maketod;

if ~iscell(mapopt)
  mapopt={mapopt};
end

% These are the pairmaps that will be generated
fname=whichpairmaps(tags,rlz,mapopt,nbase,type,subsim);

% Do these pairmaps exist?
if onlymissing
  haspairmap=whichpairmapsexist(fname,rlz);
else
  % make them all
  haspairmap=false(size(fname));
end

% If not farming jobs, exit
if onlymissing==2
  return
end

% If more than one pairmap is being made per tag/realization (i.e. if mapopt is a cell
% array of mapopts) then if one is missing, the others must be generated too. Thus
% collapse haspairmap over the third dimension with an AND operation.
haspairmap=sum(haspairmap,3);
haspairmap=haspairmap==size(fname,3);

% Break realizations up into chunks for farming
for k=1:numel(tags)
  if onlymissing
    % only the missing tags and realizations
    dorlz=rlz(~haspairmap(:,k));
  else
    % all tags and all realizations
    dorlz=rlz;
  end
  rlzchunks{k}=get_rlzchunk(dorlz,rlzchunksize);
end


%%%%%%%%%%%%%
% Farm sims %
%%%%%%%%%%%%%

% what host are we?
host=whichhost;

% this is the proper serial number
simopt.sernum=sprintf('%04dxxx%1d',nbase,type);

% these are the signal/noise options
simopt.sig=sig;
simopt.noise=noise;

% these mapopts are used when not writing the TOD to disk
simopt.mapopt=mapopt;

% runsim will check which pairmaps are missing
% however, when a farm job gets resubmitted
% this check needs to be done in reduc_makesim:
simopt.update=onlymissing;

% split up tags into tag chunks
ntagchunks=ceil(numel(tags)/tagchunksize);
for i=1:ntagchunks
  s=1+(i-1)*tagchunksize;
  e=min(s+tagchunksize-1,numel(tags));
  tagchunk{i}=tags(s:e);
end

for j=1:ntagchunks

  % for this set of tags, these realizations will be processed
  % if farming multiple tags, must process all realizations per tag
  if tagchunksize>1
    for k=1:numel(rlz)
      rlzchunk{k}=rlz(k);
    end
  else
    rlzchunk=rlzchunks{j};
  end

  for i=1:numel(rlzchunk)

    % these are the tags that will be farmed
    taglist=tagchunk{j};
    
    % what realizations are we doing?
    simopt.rlz=rlzchunk{i};
    
    % if farming multiple tags per single realizaiton, only farm the tags that are in
    % need of this realization 
    if tagchunksize>1
      keepind=true(size(taglist));
      for k=1:numel(taglist)
        ind=find(strcmp(tags,taglist{k}));
        keepind(k)=ismember(simopt.rlz,cell2mat(rlzchunks{ind}));
      end
      taglist=taglist(keepind);
    end

    % move on if there are no tags to farm
    if isempty(taglist)
      continue
    end
    
    % insert the pre-computed dither parameters
    simopt=insert_dithers(simopt,dither.simopt);
    
    % if re-running an existing noise sim, set the random seed explicitly
    if ss
      if tagchunksize>1
        error('for now, cannot set seed explicitly when farming multiple tags per realization');
      end
      simopt=setseed(simopt,tags{j});
    end
    
    % farm the sims
    farmsim(taglist,simopt,host,joblimit,j,excludehosts,dofarm,queue,memusg,usecompiled,maxtime,submit);
    
    % if farming on SPUD, only run a few jobs at a time
    whatisnextstep(host,nbase)
    
  end
  
end

return


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function fname=whichpairmaps(tags,rlz,mapopt,nbase,type,subsim)

for i=1:numel(rlz)
  for j=1:numel(mapopt)
    mapopt0=mapopt{j};
    mapopt0.sernum=sprintf('%04d%03d%01d',nbase,rlz(i),type);
    mapopt0=get_default_mapopt(mapopt0);
    if subsim
      mapopt0.weight=0;
    end
    f=get_pairmap_filename(tags,mapopt0);
    for k=1:numel(tags)
      fname{i,k,j}=f{k};
    end
  end
end

return


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function haspairmap=whichpairmapsexist(fname,rlz)

% hard coded
checksize=0;
checkload=0;

% looping over tags is not significantly slower than listing all files at once
haspairmap=false(size(fname));
for i=1:size(haspairmap,1)
  disp(sprintf('checking files for realization %d (%d of %d)',rlz(i),i,size(haspairmap,1)));
  for j=1:size(haspairmap,2)
    for k=1:size(haspairmap,3)
      if checksize
        d=dir(fname{i,j,k});
        haspairmap(i,j,k)=~isempty(d) && d.bytes>0;
      elseif checkload
        try
          load(fname{i,j,k},'m');
          haspairmap(i,j,k)=true;
        catch
          haspairmap(i,j,k)=false;
        end        
      else
        haspairmap(i,j,k)=logical(exist(fname{i,j,k},'file'));
      end
    end
  end
  disp(sprintf('  %d of %d pairmaps are missing', ...
               sum(sum(~haspairmap(i,:,:))) , numel(haspairmap(1,:,:))));
end

% Display info
disp(sprintf('**%d of %d pairmaps are missing**',...
             sum(sum(~haspairmap)),numel(haspairmap)));


return


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function simopt=insert_dithers(simopt,ditheropt)

flds=fieldnames(ditheropt);
for k=1:numel(flds)
  fld=flds{k};
  switch fld
   case {'rndeps','rndchi','rndcen','rndsig','rndelp','rndelc','abgain'}
    x=getfield(ditheropt,fld);
    if size(x,2)>1 & ~simopt.rlz==0
      [dum,ind]=intersect(ditheropt.rlz,simopt.rlz);
    else
      ind=1;
    end
    simopt=setfield(simopt,fld,x(:,ind,:)); %second ";" needs to be there for dithers set up as matrix as rndwid
  end
end

return


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function simopt=setseed(simopt,tag)

% Get the pairmap filename. The pairmap must exist. If multiple pairmaps have been made
% for a single sim tag/realization, they will all have the same random seed, so just
% use the first one.
mapopt=get_default_mapopt(simopt.mapopt{1});
for i=1:numel(simopt.rlz)
  mapopt.sernum=sprintf('%s%03d%s',simopt.sernum(1:4),simopt.rlz(i),'1');
  fname=get_pairmap_filename(tag,mapopt);
  load(fname,'mapopt');
  simopt.state{1,i}=mapopt.simopt.state;
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function farmsim(tags,simopt,host,joblimit,j,excludehosts,dofarm,queue,memusg,usecompiled,maxtime,submit)

% Set up odyssey parameters
username=whoami();

% Group name
experiment=get_experiment_name;
GROUP=sprintf('/%s_sim_%s',experiment,username);

% Create group and limit the number of jobs
%  if strcmp(host,'odyssey') & j==1
%    % This usually only happens when farming all sims, not just missing data, because the
%    % first time this code is executed j will not be 1
%    system(['bgadd ' GROUP]);
%    system(sprintf('bgmod -L %d %s',joblimit,GROUP));
%  end

QUEUE=queue;

% Don't run jobs on these hosts
if ~isempty(excludehosts)
  % append to ARGS
  ARGS=' -R "';
  for i=1:numel(excludehosts)
    ARGS=[ARGS 'hname!=' excludehosts{i}];
    if i<numel(excludehosts)
      ARGS=[ARGS ' && '];
    end
  end
  ARGS=[ARGS '"'];
else
  ARGS=[];
end

% - farmfiles have form farmfiles/XXXX/tag_YYYZ.xxx
% - jobnames have form XXXX_tag_YYYZ
% eg. farmfiles/0304/20120403E02_dk113_0511.mat &
%     0304_20120403E02_dk113_0511
farmfilebase=sprintf('%s_%03d%s',tags{1},simopt.rlz(1),simopt.sernum(end));
farmfiledir=sprintf('farmfiles/%s',simopt.sernum(1:4));
if ~exist(farmfiledir,'dir')
  system(['mkdir ' farmfiledir]);
end

farmfile=sprintf('%s/%s.mat',farmfiledir,farmfilebase);
outfile=sprintf('%s/%s.out',farmfiledir,farmfilebase);
errfile=sprintf('%s/%s.err',farmfiledir,farmfilebase);

JOBNAME=sprintf('%s_%s',simopt.sernum(1:4),farmfilebase);

% commented this out since below the skipping stuff is used
%  % if the farmfile already exists delete it, otherwise farmit doesn't like it
%  if exist(farmfile,'file')
%    system(['rm -f ' farmfile]);
%  end

% if usecompiled is false, run reduc_makesim as normal
if ~usecompiled
  cmd='reduc_makesim(tags,simopt)';
% otherwise use compiled version of reduc_makesim
else
  cmd='reduc_makesim ';
end

if dofarm
  if ~exist(farmfile,'file')
    farmit(farmfile,cmd,...
           'group',GROUP,'queue',QUEUE,'mem',memusg,...
           'jobname',JOBNAME,'var',{'tags','simopt'},...
           'errfile',errfile,'outfile',outfile,'args',ARGS,...
           'usecompiled',usecompiled,'maxtime',maxtime,...
           'submit',submit);
  else
    display(['Skipping over existing job: ',farmfile])
  end
else
  eval(cmd);
end

return


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
function rlzchunk=get_rlzchunk(rlz,rlzchunksize)

if isempty(rlz)
  rlzchunk={};
  return
end

nchunks=ceil(numel(rlz)/rlzchunksize);
for i=1:nchunks
  s=1+(i-1)*rlzchunksize;
  e=min([i*rlzchunksize,numel(rlz)]);
  rlzchunk{i}=rlz(s:e);
end

return


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function whatisnextstep(host,nbase)

if strcmp(host,'spud')
  % max jobs that will run at once
  Nproclimit=Inf;
  Nproc=Inf;

  while Nproc>=Nproclimit
    pause(2)
    Nproc=numel(myprocesses(sprintf('farmfiles/%04d',nbase)));
  end
end

return


