<!DOCTYPE html>

<!--suppress HtmlDeprecatedAttribute -->
<head>
    <meta charset="utf-8">
    <title>IPR Analysis 2: B18 Sims</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Load up MathJax for math notation -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript"
            src="../mathjax/MathJax.js?config=TeX-AMS-MML_SVG">
            // src="../mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body>
<!-- Add my custom pager script -->
<script type="text/javascript" src="scripts/pager.js"></script>
<link rel="stylesheet" type="text/css" href="scripts/pager.css">

<header>
    <h1>Isotropic Polarization Rotation Analysis 2: Angle Estimates on Matrix-Purified B18 sims</h1>

    <time datetime="2022-02-14" class="published updated">
        2023 Feb 14
    </time> —
    J. Cornelison
</header>

<hr>

<p>
In a previous posting <a href="JAC2023"></a>, I characterized the uncertainty in global polarization estimates for BICEP3 B2018 sims which are expected to have a mean angle of 0&deg;. This is a follow-up to that posting which now includes fits to the B18 3-year dataset and I compare angle fits to B18 to B2018. I then investigate how each bandpower is weighted by the angle estimator. Lastly, I explore a bit more how the variance on our angle estimates and BB-power relate to each other.
</p>

<hr>

<section><h2>Matrix purifying B18 Sims</h2>
    <p>
I've now included B18 into these pagers. I am also now crossing Unlensed LCDM T&E with B of Dust-only and Noise-only signal types so that our angle estimates for these signal types are comparable to the ones with CMB already in them.
        These spectra can be seen in the "cmb x noise/dust" option where EB, TB, and BB are all now E<sub>CMB</sub>&times;B<sub>Noise/Dust</sub> , T<sub>CMB</sub>&times;B<sub>Noise/Dust</sub> , B<sub>CMB</sub>&times;B<sub>Noise/Dust</sub> respectively.
    </p>

<!--    <p>-->
<!--        Sim types:-->
<!--        <ol start="2">-->

<!--        <li>Unlensed &Lambda;CDM</li>-->
<!--        <li>Gaussian Dust</li>-->
<!--        <li>Unlensed &Lambda;CDM + r=0.1</li>-->
<!--        <li>Lensed &Lambda;CDM</li>-->
<!--        <li>Sign-flip noise</li>-->
<!--        <li>Lensed &Lambda;CDM+Noise [Type 5+6]</li>-->
<!--        <li>Lensed &Lambda;CDM+Noise+Dust [Type 7+3]</li>-->
<!--    </ol>-->
<!--    </p>-->
<!--    -->

    <ul>
        <li><b>B18</b> - the ensemble of 499 B18 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: fgh)</li>
        <li><b>B2018</b> - the ensemble of 499 B2018 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: h)</li>
        <li><b>B2018-rerun</b> - An ensemble of 10 B2018 sims I ran myself (sernum: 6600, daughter: h).</li>
    </ul>


    <figure>
        <img alt="Name pager" id="apspager" src="#" width="65%" onerror=this.src="figs/blank_6x6.png" />
        <figcaption>
            A pager of EB/TB APS of my 10 sims compared to the 499 sims generated for B2018. The gray lines indicate one realization and the black line indicates the mean of all realizations per-ell.
        </figcaption>
        <script type="text/javascript">
            pager.link("#apspager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure': ['None|','Matrix|matrix_'],
                    'Simset|sernum': ['B18|6614_fgh','B2018|6614_h','B2018-rerun|6600_h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                    'y-axes|axes': ['Fixed|_fixed','Free|_free']
                },
                function(params) {
                    return 'figs/aps_'+params.sernum+'_'+params.pure+params.sig+params.axes+params.c+'_bins_2_10.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': 'matrix_',
                'sernum': '6614_fgh',
                'c': '_cross',
                'axes': '_free',
            });
        </script>
    </figure>

    <p>I see a ~20% reduction in the B18 and B2018 matrix-purified Unlensed-LCDM BB spectra. Below I show the angle estimates now including crosses of CMB with Dust/Noise. As in my previous posting, I fit angles using only our standard &ell;-bins of 2 through 10 (out of 17).</p>

    <figure>
        <img alt="Name pager" id="histpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Histograms of &alpha; estimates for B2018 and my B2018-rerun for each EB/TB fit type; per signal type; and with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#histpager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure2': ['None|','Matrix|matrix_'],
                    'Simset|sernum2': ['B18|6614fgh','B2018|6614h','B2018-rerun|6600h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                },
                function(params) {
                    return 'figs/alpha_hist_'+params.sernum2+params.pure2+params.sig+'_corr'+params.c+'_bins_2_10.png';
                });
            pager.setparams({
                'sig': '2',
                'pure2': 'matrix_',
                'sernum2': '6614fgh',
                'c': '_cross',
            });
        </script>
    </figure>


<p>

</p>

    <figure>
        <img alt="Name pager" id="ebvtbpager" src="#" onerror=this.src="figs/blank_6x4.png" width="75%"/>
        <figcaption>
            Histograms of &alpha; estimates for B2018 and my B2018-rerun for each EB/TB fit type; per signal type; and with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#ebvtbpager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure2': ['None|','Matrix|matrix_'],
                    'Simset|sernum2': ['B18|6614fgh','B2018|6614h','B2018-rerun|6600h'],
                    //'cmb x noise/dust|c': ['Off|','On|_cross'],
                },
                function(params) {
                    return 'figs/alpha_eb_vs_tb_'+params.sernum2+params.pure2+params.sig+'_corr'+params.c+'_bins_2_10.png';
                });
            pager.setparams({
                'sig': '2',
                'pure2': 'matrix_',
                'sernum2': '6614fgh',
                'c': '_cross',
            });
        </script>
    </figure>

    <p>
        Switching between B18 and B2018 for any signal type which has noise, we can qualitatively see that integrating over three years versus one reduces the &sigma;<sub>&alpha;</sub> as expected. Quantitatively though, we can calculate the effective number of additional years we integrated over by taking the ratio of the variances on &alpha;:
    </p>

    \begin{equation}
    \begin{split}
    &\sigma_{\alpha,B18}^2 = \frac{\sigma_{\alpha,B2018}^2}{N_{years}}\\
    & \\
    &N_{years} = \frac{\sigma_{\alpha,B2018}^2}{\sigma_{\alpha,B18}^2}\\
    \end{split}
    \end{equation}

        <p>
        and is tabluated below for each fit type:
    </p>



    <figure>
        <table>
            <tr>
                <th>Signal Type</th>
                <th colspan="3">Effective N<sub>years</sub></th>
            </tr>
            <tr>
                <th></th>
                <th>EB-only</th>
                <th>TB-only</th>
                <th>EB+TB</th>
            </tr>

            <tr>
                <td class=''>Noise-only</td>
                <td class=''>2.7368</td>
                <td class=''>2.6164</td>
                <td class=''>2.5918</td>
            </tr>

        </table>
    </figure>

    <p>The N<sub>years</sub>~2.6 for Noise-only which is close to what I get when I compare the B2018 survey weight to B18 according to the <a href="https://docs.google.com/spreadsheets/d/1k0uw5trXj5N3v-jLQMe3Z-CW_Q16NRae6zwKBb0Pxtg/view#gid=0">CMB Pol Expt Comparison Sheet</a> which is 552836/219441 = 2.52.</p>

    <p>We can also see that for B18, the means of the angles are still large compared to the error-on-the-mean, which disfavors the hypothesis in which the deviations were due to systematics resulting from using the B18 matrix on the B2018 subset. The next step is to test the other hypothesis where these deviations are due to the fact that we're using constrained T-maps.</p>
    <figure>
        <img alt="Name pager" id="eompager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Plots of the Mean divided the error on the mean as a function of each signal for cases with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#eompager",
                {
                    'Fit Type|fit' : ['EB Only|1','TB Only|2','EB+TB|3'],

                },
                function(params) {
                    return 'figs/m_over_eom_vs_sig_'+params.fit+'.png';
                });
            pager.setparams({
                'fit': '1',

            });
        </script>
    </figure>



</section>
<section>
        <h2>Angle Linear Estimator</h2>
    \(
    \newcommand{\Cl}{\mathcal{C}_\ell}
    \newcommand{\Cb}{\mathcal{C}_b}
    \newcommand{\oCb}{\mathcal{\hat C}_b}
    \newcommand{\rCb}{\mathcal{C'}_b}
    \newcommand{\Ccov}{\mathrm{\mathbf{C}}}
    \)

    Quoted from Justin's posting:
    <ul>
        <li>We can then difference model expectation values \(\rCb^{XY}\) from the
            real bandpowers \(\oCb^{XY}\) (where the subscript \(b\) denotes binned
            bandpowers over a range in \(\ell\)) and calculate the \(χ^2\) values
            making use of the bandpower covariance matrix \(\Ccov^{XY}\) for a
            given cross-spectrum \(XY\):</li>
    </ul>
    \begin{equation}
    χ^2 = \left( \oCb^{XY} - \rCb^{XY} \right)^\top \left( \Ccov^{XY}
    \right)^{-1} \left( \oCb^{XY} - \rCb^{XY} \right)

    \end{equation}


    <p>$\hat{\alpha}_{\chi}$ is the &chi;<sup>2</sup>-estimator:</p>

    \begin{equation}
    \hat{\alpha}_\chi = \chi^2 \;\text{when}\;\;\;\frac{d\chi^2}{d\alpha}=0
    \end{equation}

    <p>Assuming the above is linear for small values of &alpha; (which should be true given the small-angle approximation), we can create a linear estimator, $\hat{\alpha}_{lin}$, in which &alpha; is the dot product between the our array of bandpowers $C_{b}^{XY}$ and some vector that contains the information how each bandpower contributes to &alpha;</p>

    \begin{equation}
    \hat{\alpha}_{lin} = \frac{\partial\alpha}{\partial C_{b}^{XY}}\,\cdot\,\hat{C}_{b}^{XY}
    \end{equation}

    <p></p>

        <p>
            I calculate $\partial\alpha\,/\,\partial C_{b}^{XY}$ by injecting a quasi-delta function -- i.e. setting a bandpower to some fixed amplitude whilst keeping all other bandpowers at zero -- into an EB or TB spectra &ell;bin-by-&ell;bin, recording the resulting alpha estimates from the &chi;<sup>2</sup>-estimator (see below figure for example). I fit angles to these fake spectra using the same procedure outlined in <a href="JAC2023"></a> where, I substitute the real data in B2018's final file for these fake spectra and then pass that final file through <tt>reduc_global_rotation.m</tt>. This means that I'm also using B2018's BPCM.</p>
        <figure>
            <img src="figs/estimator_xfer_example.gif">
            <figcaption>

            </figcaption>
        </figure>
        <p>
            The figure below shows resulting alphas for four different amplitudes of our quasi-delta function. Through my analysis so far, I have been using our standard &ell;-bins 2-10 but I now also include a case for using &ell;-bins 2-15.
        </p>

    <figure>
        <img alt="Name pager" id="xferpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Exploring the effect on &alpha; for input delta functions for EB <b>(Top Row)</b> and TB <b>(Bottom
            Row)</b>. <b>Left Column</b> Resulting &alpha; estimate per bandpower as a function of Ell, the lines are color coded by the amplitude of the quasi-delta function used in the given spectra. <b>(Right Column)</b> The angle at each bandpower is divided by the bandpower itself which creates the linear estimator. Since all four cases overlap, this is also a proof of linearity for this range of bandpowers.
        </figcaption>
        <script type="text/javascript">
            pager.link("#xferpager",
                {
                    'Bins|bins2': ['2-10|2_10','2-15|2_15'],
                },
                function(params) {
                    return 'figs/estimator_xfer_func_bins_'+params.bins2+'.png';
                });
            pager.setparams({
                'bins2': '2_10',
            });
        </script>
    </figure>

<p></p>


    <h3>Constraining power vs. &ell;</h3>
    <p>
        This shows the constraining power of the spectra as a function of &ell;-bin. Smaller values indicate higher constraining power. As such, we can expect our highest constraining power for EB to be around bins 10-12, while TB is around bins 4-6 and 8-11.
    </p>
    <figure>
        <img alt="Name pager" id="constrainpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>

        </figcaption>
        <script type="text/javascript">
            pager.link("#constrainpager",
                {
                    'Serial Number|ser': ['B18|6614_fgh','B2018|6614_h','B2018-rerun|6600_h'],
                },
                function(params) {
                    return 'figs/constraining_power_'+params.ser+'.png';
                });
            pager.setparams({
                'ser': '6614_fgh',
            });
        </script>
    </figure>





    <h3>Comparing uncertainty estimates</h3>
    <p>I determine &sigma;<sub>&alpha;</sub> by taking the dot product of $\partial\alpha\,/\,\partial C_{b}^{XY}$ and the standard deviation per-bandpower across all sims in the B18 simset.</p>
    <figure>
        <img alt="Name pager" id="estsigpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Left plots show the contribution of &sigma;<sub>&alpha;</sub> per-bandpower for EB and TB from the linear estimator. The right plot compares the &sigma;<sub>&alpha;</sub> between the linear and chi-squared estimator.
        </figcaption>
        <script type="text/javascript">
            pager.link("#estsigpager",
                {
                    'Bins|bins2': ['2-10|2_10','2-15|2_15'],
                },
                function(params) {
                    return 'figs/sigalpha_lin_vs_chi_bins_'+params.bins2+'.png';
                });
            pager.setparams({
                'bins2': '2_10',
            });
        </script>
    </figure>

    <h3>Comparing &alpha; estimates</h3>
    <p>

    </p>
    <figure>
        <img alt="Name pager" id="linestpager" src="#" onerror=this.src="figs/blank_6x4.png" width="75%"/>
        <figcaption>
            Each dot represents a single realization from B18. &alpha; along the y-axis is calculated by taking the dot product of d&alpha;/dD<sub>&ell;</sub> in the right plots of Fig 2.2 with their respective band powers.
        </figcaption>
        <script type="text/javascript">
            pager.link("#linestpager",
                {
                    'Signal Type|sig31': ['Unlensed-LCDM|1','G. Dust|2','Lensed-LCDM|3','Noise|4','L-LCDM+Noise|5','L-LCDM+Noise+Dust|6'],
                    'Bins|bins2': ['2-10|2_10','2-15|2_15'],
                },
                function(params) {
                    return 'figs/alpha_chi_vs_linear_type_'+params.sig31+'_bins_'+params.bins2+'.png';
                });
            pager.setparams({
                'sig31': '2',
                'bins2': '2_10',
            });
        </script>
    </figure>






</section>

<section>
    <h2>Looking into the $\hat{\alpha}_\chi$ Covariance Matrix</h2>

    <p>As mentioned before <tt>reduc_global_rotation</tt> estimates an angle by minimizing the equation below</p>

    \begin{equation}
    χ^2 = \left( \oCb^{XY} - \rCb^{XY} \right)^\top \left( \Ccov^{XY}
    \right)^{-1} \left( \oCb^{XY} - \rCb^{XY} \right)

    \end{equation}

    <p>Where $\Ccov^{XY}$ in this case is the EBEB or the TBTB covariance matrix. </p>

    <p>First, since the code also allows for estimating &alpha; with EB+TB, I had assumed the above equation would be extended in such a way which considers the TBEB and TBEB cross-covariance in the full bandpower covariance matrix.
    </p>
    <p>
        If we use $\Ccov$ to describe the full bandpower covariance matrix between EB and TB with submatrices $\Ccov^{XY}$, I expected the covariance in the estimator to look like

    </p>

    \begin{equation}
    \Ccov =
    \begin{bmatrix}
    \Ccov^{TBTB} & \Ccov^{TBEB} \\
    \Ccov^{EBTB} & \Ccov^{EBEB} \\
    \end{bmatrix}
    \end{equation}

<p>
    which would be taken directly from the final file's given bandpower covariance matrix. Instead, the the code recalculates the bandpower covariance for just TBTB and EBEB doesn't actually include the cross-covariance between the two:
</p>
    \begin{equation}
    \Ccov =
    \begin{bmatrix}
    \Ccov^{TBTB} & O \\
    O & \Ccov^{EBEB} \\
    \end{bmatrix}
    \end{equation}

<p>
    Second, like our actual BPCM, the coavriance matrix above is calculated from the final file's <tt>final.r.sim</tt> variable which are the 499 noise-debiased Type-7 sims (i.e. Lensed-LCDM+Noise-mean(Noise)) -- <tt>reduc_final.m</tt> states that this debiasing is done for <i>all</i> spectra, not just BB.
</p>

    <p>
        I re-fit alpha to the B18, B2018, and B2018-rerun sims now using the full bandpower covariance matrix calculated from Lensed-LCDM+Noise+Dust. To show the effects of only changing one thing at a time, in the pager below, the first "Full Cov." option uses the full, original covariance matrix (Noise-debiased L-LCDM+Noise). The "Full Cov. from Type 8" option uses the full covariance matrix recalculated from L-LDCM+Noise+Dust without debiasing.
    </p>

    <p>Lastly, Justin points out in this posting that he truncates the covariance matrix to keep only up to the 2nd off-diagonal terms which is the default choice in the code. While not stated explicitly, I assume this choice is made because he didn't trust the covariance matrix to be a 100% match of the covariance on the real data. Because I have been using this default choice, I include an option to choose between using all off-diagonal terms or just the default of 2.</p>

    <figure>
        <img alt="Name pager" id="hist123pager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Histograms of &alpha; estimates for B2018 and my B2018-rerun for each EB/TB fit type; per signal type; and with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#hist123pager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    //'Purification Method|pure2': ['None|','Matrix|matrix_'],
                    'Simset|sernum10': ['B18|6614fgh','B2018|6614h','B2018-rerun|6600h'],
                    //'cmb x noise/dust|c': ['Off|','On|_cross'],
                    'bins|b':['2-10|_2_10', '2-15|_2_15'],
                    'Cov. Mat.|cov' : ['Original|','Full Cov.|_fullcov','Full Cov. from Type 8|_fullcov_repsim'],
                    'Off-diag|off' : ['2|','All|_alloff'],
                },
                function(params) {
                    return 'figs/alpha_hist_'+params.sernum10+'matrix_'+params.sig+'_corr_cross_bins'+params.b+params.cov+params.off+'.png';
                });
            pager.setparams({
                'sig': '8',
                //'pure2': 'matrix_',
                'sernum10': '6614fgh',
                //'c': '_cross',
                'b':'_2_10',
                'cov': '_fullcov_repsim',
                'off': '_alloff',
            });
        </script>
    </figure>

    <p>
        Including the covariance information between EB and TB, the fit to EB+TB does appear to being EB+TB closer to EB-only, but it's still higher than EB-only.
    </p>

</section>


<section><h2>Conclusions</h2>
    <p>
        In my previous posting, we saw deviations in the means of &alpha; that were large WRT their error-on-the-means. By fitting angles to B18, I was able to rule out systematics involving the purification matrix as the source which drives us to look into ways of testing the hypothesis that these deviations are a result from using constrained T-maps.
    </p>

    <p>
        By fitting angles to EB/TB with CMB crossed Noise/Dust, the angles that I fit to these signal types are now comparable to the other signal types with CMB in them. I find that the Noise &sigma;<sub>&alpha;</sub> between B2018 and B18 drops by ~&radic;3 as expected. This is not true, however, for L-LCDM+Noise or L-LCDM+N+Dust because we're now in the regime where the contributions to &sigma;<sub>&alpha;</sub> from lensing and noise are comparable.
    </p>

    <p>
        I also examined how each bandpower contributes to our angle estimates and find that most of our constraining power is in the higher-&ell;'s. For all of my angle fits up through now I have been only using &ell;-bins between 2 and 10 (&ell;=37.5 to 317.5), but because the BB-power in our real data is less understood at higher &ell;'s, I'm thinking of sticking to this &ell;-bin range. According to the fits in Fig 2.4, most of our constraining power in this region is between &ell;-bins of 6 to 10, but we do see a non-trivial improvement of &sigma;<sub>&alpha;</sub> of ~0.01&deg; by including bands 2 through 5, so I'm electing to keep using those as well.
    </p>

    <p>
        I was able to show that the sum of the BB-power and the variance on &alpha; of the L-LCDM, Noise and Dust signal types are equal to the BB-power and &sigma;<sub>&alpha;</sub><sup>2</sup> of coadded maps of the signal types. This relationship should prove useful both when looking at fits of other simulations further on in the analysis and when forcasting the performance of future analyses.
    </p>
    <p>Lastly, I was able to show that if we include two more years of data, our constraint would start to be dominated by the lensing signal instead of noise.</p>


    <h3>Next Steps</h3>
<ul>
    <li>Running pseudosims through the angle estimator explore how EB and TB are related</li>
    <li>Fitting angles to sims with non-zero angles injected into them.</li>
</ul>

</section>

<hr>

<section class="appendix">
<h2 class="appendix">Appendix</h2>
    <h3>Footnotes</h3>
    <p>Click on the number to return to the main text.</p>
    <div class="footnote">
        <p>
        <sup><a name="ftn1" href="#sup1">[1]</a></sup>

    </p>
    </div>
<!--    <h3>Code</h3>-->
<!--    <p>Below is a list of code that was used for this analysis. The code is committed to the pipeline and can be found in the <tt>analysis/beammap/</tt> directory.</p>-->
<!--    <p id="code"></p>-->

<!--    <h3>Data</h3>-->
<!--    <p id="data"></p>-->
    <h3>References</h3>

    <p id="references"></p>


    <p id="testp"></p>

    <script type="text/javascript">

        // Shorthand tags
        var codes = [
            "rps_fit_mirror_from_moon.m",
            ];

        // Posting titles
        var desc = [
            "Derives mirror parameters from observations of the moon.",
        ];

        // Make a list of references
        var post = document.getElementById("code");
        var msg = "<table class=\"code\">";
        for (var code in codes){
            msg = msg + "<tr><td><tt>"+codes[code]+"</tt></td><td> - </td><td>"+desc[code]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

    </script>

    <script type="text/javascript">

        // Shorthand tags
        var data = [
            "moonsch.mat",
            ];

        // Posting titles
        var desc = [
            "Metadata of Moon observations",
            ];

        // Make a list of references
        var post = document.getElementById("data");
        var msg = "<table class=\"code\">";
        for (var datum in data) {
            msg = msg + "<tr><td><tt>" + data[datum] + "</tt></td><td> - </td><td>" + desc[datum] + "</td>";
        }
        ;
        msg = msg + "</table>";
        post.innerHTML = msg;

    </script>



    <script type="text/javascript">

        // This my way of making shorthand links.
        // We'll make a couple arrays with the 'tag' and href information
        // and then look through each anchor element for the specified tag.
        // The anchors should then just look like: <a href="tagname"></a>
        // and the script will automatically fill in the hyperlings and text.


        var posting_dir = window.location.href; // What's the current url?

        var bkurl = "bicep.rc.fas.harvard.edu";
        var spurl = "bicep.usap.gov";

        // These are the possible places to find postings
        // The strings are for if you post your posting in that directory.
        var sitemap = {
            jcornelison: "../../../",   // /jcornelison/postings/
            bkcmb : "../../../../",     // /bkcmb/analysis_logbook/analysis/
            bicep3: "../../../",        //
            bicep_array: "../../../",   //
            bicep2: "",                 // We shouldn't be posting in these, but still have postings we can reference.
            keck  : "",                 // keck/analysis_logbook/analysis/
            spuder: "",                 // ~spuder/hieno_analysis_logboo
            bicep1: "",                 // ~bicep1/analysis_logbook_north/
            general_projects:"",
                   };
        // Logbook Site map:
        // personal:www/jcornelison/postings/
        // bkcmb:   www/bkcmb/analysis_logbook/analysis/
        // keck:    www/keck/analysis_logbook/analysis/
        // BICEP3:  www/bicep3/analysis_logbook/
        // BA:      www/bicep_array/analysis_logbook/
        // We shouldn't be posting in these, but still have postings.
        // bicep2:
        // keck:    www/keck/analysis_logbook/analysis/
        // spuder:  www/~spuder/hieno_analysis_logbook/
        // bicep1:  www/~bicep1/analysis_logbook_north/

        // Shorthand tags
        var tags = [
            "Carroll1990",
            "Harari1992",
            "Kaufman2013",
            "JBW2016",
            "EWB2016",
            "BKIX",
            "BKXII",
            "BKXIV",
            "BKXVII",
            "JAC2023",
        ];

        // Links
        // Truncate the link down to the www directory in which it lies if you can.
        // This ensures that we can view the linked postings at Pole without the internet.
        var hrefs = [
            "papers/carroll1990.pdf",
            "papers/harari1992.pdf",
            "https://arxiv.org/pdf/1312.7877.pdf",
            "bkcmb/analysis_logbook/analysis/20160907_polrot/",
            "bkcmb/analysis_logbook/analysis/20161215_rot_sims_polrot/",
            "https://arxiv.org/pdf/1705.02523.pdf",
            "https://arxiv.org/pdf/2011.03483.pdf",
            "https://arxiv.org/pdf/2108.03316.pdf",
            "https://arxiv.org/pdf/2210.08038.pdf",
            "bkcmb/analysis_logbook/analysis/20230207_IPR_angle_fits_to_B2018/",


        ];


        // Posting titles
        var desc = [
            "Limits on a Lorentz- and parity-violating modification of electrodynamics",
            "Effects of a Nambu-Goldstone boson on the polarization of radio galaxies and the cosmic microwave background",
            "Self-Calibration of BICEP1 Three-Year Data and Constraints on Astrophysical Polarization Rotation",
            "Birefringence/Polarization rotation in K2015 and BK15",
            "Polarization Rotation Sims Global Rotation",
            "New Bounds on Anisotropies of CMB Polarization Rotation and Implications for Axion-Like Particles and Primordial Magnetic Fields",
            "Constraints on axion-like polarization oscillations in the cosmic microwave background",
            "Improved Constraints on axion-like polarization oscillations in the Cosmic Microwave Background",
            "Line of Sight Distortion Analysis: Estimates of Gravitational Lensing, Anisotropic Cosmic Birefringence, Patchy Reionization, and Systematic Errors",
            "Isotropic Polarization Rotation Analysis: Global Polarization Rotation Fits on Standard B2018 Sims",
        ];
        // Debug
        var posty = document.getElementById("testp");


        var preface = "";
        var keys = Object.keys(sitemap);
        // If we're not at pole or bicep, just post the full URL
        // If we are, go back to the www directory.
        if (posting_dir.match(new RegExp(bkurl))!=bkurl &
            posting_dir.match(new RegExp(spurl))!=spurl){
                preface = "http://" + bkurl+"/";
            }
        else {
            for (key in keys){
                if (posting_dir.match(new RegExp("/"+keys[key]+"/"))=="/"+keys[key]+"/"){
                    preface = sitemap[keys[key]];
                };
            };

        };

        // Add the prefixes we can.
        // Only add prefixes to directories in the sitemap so we don't break
        // external references.
        for (ref in hrefs) {
            for (key in keys) {

            // If there's a match, at the prefix and move on.
            if(hrefs[ref].match(new RegExp(keys[key] + "/"))==keys[key]+"/"){
                hrefs[ref] = preface+hrefs[ref];
                break;
            }
            };
        };

        // posty.innerHTML = preface;

        // Make a list of references
        var post = document.getElementById("references");
        var msg = "<table>";
        for (var tag in tags){
            msg = msg + "<tr><td><a href="+tags[tag]+"></a></td><td> - </td><td>"+desc[tag]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

        // Look through all the hyperlinks and insert the proper links to the postings
        var links = document.getElementsByTagName("A");
        for (var link in links){
            for (var tag in tags){
                if (links[link].href.endsWith(tags[tag])){
                    links[link].text = "("+tags[tag]+")";
                    links[link].href = hrefs[tag];
                    links[link].target = "_blank";
                }
            }
        }

    </script>
</section>




</body>
