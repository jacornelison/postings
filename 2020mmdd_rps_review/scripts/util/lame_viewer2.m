function lame_viewer2(map, channel, varargin)
% lame_viewer(map, channel, ...)
%
%   Draw beams from maps generated by lame_mapper.
%
%   The maps are binned in phi and theta for a spherical coordinate
%   system with the boresight of the pixel at the north pole. To
%   visualize the spherical coordinates, we project to a plane tangent
%   to the sphere at the boresight and resample the tangent plane with
%   square pixels.
%
%   Inputs:
%     map       Map data structure generated by lame_mapper.
%     channel   Channel number to plot.
%   Keyword arguments:
%     'Log'     Specify this keyword to plot the map on a logarithmic
%               scale (base 10). The abs function is applied to the
%               map before taking the logarithm.
%     'CLim', [low high]
%               Specify this keyword to manually set the range of the
%               color scale. By default, the color scale will be set
%               to the full range of the map. Note that range
%               specified with the 'CLim' keyword is not transformed
%               based on the presence of the 'Log' keyword.
%     'NPix', value
%               Specify this keyword to manually specify the number of
%               pixels used to sample the tangent plane. Default value
%               is 201.
%     'ThetaMax', value
%               Specify this keyword to set the range of theta
%               coordinate to plot (in degrees). The valid range is 0
%               to 90. Default value is 90.
%     'Graticule', [theta_step, phi_step]
%               Specify this keyword to add a graticule to the
%               plot. By default, the graticule has lines spaced by 30
%               degrees in theta and 60 degrees in phi. The line
%               spacing can be specified by following the keyword
%               with a vector argument containing the spacing in theta
%               and phi.

% 2011-12-06 CAB

% Parse optional arguments.
plotlog = 0;
clim = [];
npix = 201;
thetamax = 90;
graticule = 0;
graticule_theta_step = 30;
graticule_phi_step = 60;
for i=1:length(varargin)
  % Logarithmic map.
  if strcmp(varargin{i}, 'Log')
    plotlog = 1;
  end
  
  % Select color scale.
  if strcmp(varargin{i}, 'CLim')
    value = double(varargin{i + 1});
    if (length(value) == 2) & (value(1) < value(2))
      clim = value;
      i = i + 1;
    end
  end

  % Select plot size.
  if strcmp(varargin{i}, 'NPix')
    value = double(varargin{i + 1});
    if (value > 0)
      npix = value;
      i = i + 1;
    end
  end
  
  % Select plot range.
  if strcmp(varargin{i}, 'ThetaMax')
    value = double(varargin{i + 1});
    if (value > 0) & (value < 90)
      thetamax = value;
      i = i + 1;
    end
  end

  % Plot graticule.
  if strcmp(varargin{i}, 'Graticule')
    graticule = 1;
    % Check if graticule spacing is specified.
    if (length(varargin) > i)
      if isvector(varargin{i + 1}) & (length(varargin{i + 1}) == 2)
	value = double(varargin{i + 1});
	graticule_theta_step = value(1);
	graticule_phi_step = value(2);
      end
    end
  end
end

% Get input map, with logarithmic scaling if the log keyword is set.
zin = map.data(:, :, channel);
if plotlog
  zin = log10(abs(map.data(:, :, channel)));
  zin(isinf(zin)) = NaN;
end
  
% Default color scale is the full map range.
if isempty(clim)
  clim = [min(zin(:)) max(zin(:))];
end

% Create x-y projected map.
% Oversample to resolve small pixels near theta = 0.
step = 2 / (npix - 1);
x = sin(thetamax * pi / 180) * [-1:step:1];
y = x;
zout = zeros(length(x), length(y));

maptheta = repmat(map.theta, length(map.phi), 1);
mapphi = repmat(map.phi.', 1, length(map.theta));
x_proj = sin(maptheta .* pi / 180) .* cos(mapphi .* pi / 180);
y_proj = sin(maptheta .* pi / 180) .* sin(mapphi .* pi / 180);
%This is going to average after taking log of power, okay for visualization, but be careful if doing any analysis after such non-linear average
zout = double(grid_map(x_proj(:), y_proj(:), zin(:), x, y));

if 0
% Fill projected map by just figuring out which bin from the (theta,
% phi) map each (x, y) pixel would fall into. So no interpolation at
% all (for now).
for i=1:length(x)
  for j=1:length(y)
    theta_proj = asin(sqrt(x(i)^2 + y(j)^2)) * 180 / pi;
    if ~isreal(theta_proj)
      zout(i, j) = NaN;
    else
      theta_bin = max(find(theta_proj > map.theta));
      phi_proj = atan2(y(j), x(i)) * 180 / pi;
      phi_bin = max(find(phi_proj > map.phi));
      if ~isempty(theta_bin) && ~isempty(phi_bin)
	zout(i, j) = zin(phi_bin, theta_bin);
      else
	zout(i, j) = NaN;
      end
    end
  end
end
end


% Draw projected image.
imagesc(x, y, zout, clim);
colorbar();
axis off;
axis square;

% Draw graticule.
%   30 degree steps in theta.
%   60 degree steps in phi.
if graticule
  hold on;
  % Lines of constant theta are circles.
  phi = [-pi:0.05:pi];
  for theta=[graticule_theta_step:graticule_theta_step:thetamax]
    plot(sin(theta * pi / 180) * cos(phi), ...
	sin(theta * pi / 180) * sin(phi), 'k');
  end
  % Lines of constant phi are straight lines.
  sintheta = [0 1];
  for phi=[0:graticule_phi_step:360]
    plot(cos(phi * pi / 180) * sintheta, ...
	sin(phi * pi / 180) * sintheta, 'k');
  end
end
