<!DOCTYPE html>

<!--suppress HtmlDeprecatedAttribute -->
<head>
    <meta charset="utf-8">
    <title>Isotropic Polrot Analysis: B2018 Sims</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Load up MathJax for math notation -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
              tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript"
            src="../mathjax/MathJax.js?config=TeX-AMS-MML_SVG">
            // src="../mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body>
<!-- Add my custom pager script -->
<script type="text/javascript" src="scripts/pager.js"></script>
<link rel="stylesheet" type="text/css" href="scripts/pager.css">

<header>
    <h1>Isotropic Polarization Rotation Analysis: Global Polarization Rotation Fits on Standard B2018 Sims</h1>

    <time datetime="2022-12-13" class="published updated">
        2023 Feb 7
    </time> â€”
    J. Cornelison
</header>

<hr>

<p>

</p>

<hr>

<section><h2>Introduction</h2>
</section>


<section><h2>Recreation of B2018 Sims</h2>
    <p>
I've now included B18 into these pagers. I am also now crossing CMB T&E with B for Dust-only and Noise-only signal types.
    </p>
    <p>
        The pager below shows EB/TB angular power spectra (APS) for both B2018 (sernum 3553) and my sims (B2018-rerun, sernum 6600) where I visually compare the means. To see if it can improve the fits to EB/TB spectra, I also apply the B18 purification matrix -- which was created from the combined B2016, B2017, and B2018 -- to both sets of sims.
</p>
<!--    <p>-->
<!--        Sim types:-->
<!--        <ol start="2">-->

<!--        <li>Unlensed &Lambda;CDM</li>-->
<!--        <li>Gaussian Dust</li>-->
<!--        <li>Unlensed &Lambda;CDM + r=0.1</li>-->
<!--        <li>Lensed &Lambda;CDM</li>-->
<!--        <li>Sign-flip noise</li>-->
<!--        <li>Lensed &Lambda;CDM+Noise [Type 5+6]</li>-->
<!--        <li>Lensed &Lambda;CDM+Noise+Dust [Type 7+3]</li>-->
<!--    </ol>-->
<!--    </p>-->
<!--    -->

    <ul>
        <li><b>B18</b> - the ensemble of 499 B18 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: fgh)</li>
        <li><b>B2018</b> - the ensemble of 499 B2018 sims created for the BK18 analysis (i.e. sernum: 3553, daughter: h)</li>
        <li><b>B2018-rerun</b> - An ensemble of 10 B2018 sims I ran myself (sernum: 6600, daughter: h).</li>
    </ul>


    <figure>
        <img alt="Name pager" id="apspager" src="#" width="65%" onerror=this.src="figs/blank_6x6.png" />
        <figcaption>
            A pager of EB/TB APS of my 10 sims compared to the 499 sims generated for B2018. The gray lines indicate one realization and the black line indicates the mean of all realizations per-ell.
        </figcaption>
        <script type="text/javascript">
            pager.link("#apspager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure': ['None|','Matrix|matrix_'],
                    'Simset|sernum': ['B18|6614_fgh','B2018|6614_h','B2018-rerun|6600_h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                    'y-axes|axes': ['Fixed|_fixed','Free|_free']
                },
                function(params) {
                    return 'figs/aps_'+params.sernum+'_'+params.pure+params.sig+params.axes+params.c+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure': '',
                'sernum': '6600_h',
                'cross': '',
                'axes': '_fixed',
            });
        </script>
    </figure>
<p>
    Switching between the two simsets for any signal-type, we can see that my reproduction was successful. We can also see qualitatively that the purification matrix does a great job of reducing E-to-B leakage which should reduce the variance on &alpha; estimates.
</p>
</section>
    <section><h2>Global Polarization Rotation fits to B2018 Sims</h2>
    <p>
        Now I perform the global rotation fits on each of the sims.
    </p>
    <p>
        I estimate &alpha; for each individual sim following the procedure outlined by Eric Bullock in <a href="EWB2016"></a>:
        <ol>
        <li>Load in a real final file and sim APS.</li>
        <li>Apply the suppression factor from the real data to the sim APS.</li>
        <li>Swap the real APS for the sim APS in the final file.</li>
        <li>Pass the final file through <tt>reduc_global_rotation</tt> to fit for the angle.</li>
    </ol>
        This method ensures that each simmed APS has the same suppression factor and bandpower window function (BPWF) applied as the real data and also that the fit is properly normalized by the bandpower covariance matrix (BPCM).
    </p>
    <p>

    </p>
    <figure>
        <img alt="Name pager" id="histpager" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
        <figcaption>
            Histograms of &alpha; estimates for B2018 and my B2018-rerun for each EB/TB fit type; per signal type; and with and without matrix purification.
        </figcaption>
        <script type="text/javascript">
            pager.link("#histpager",
                {
                    'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                    'Purification Method|pure2': ['None|','Matrix|matrix_'],
                    'Simset|sernum2': ['B18|6614fgh','B2018|6614h','B2018-rerun|6600h'],
                    'cmb x noise/dust|c': ['Off|','On|_cross'],
                },
                function(params) {
                    return 'figs/alpha_hist_'+params.sernum2+params.pure2+params.sig+'_corr'+params.c+'.png';
                });
            pager.setparams({
                'sig': '2',
                'pure2': '',
                'sernum2': '6600h',
                'c': '',
            });
        </script>
    </figure>

    <p>

    </p>
        <figure class="table">
            <table class="results">
                <tr>
                    <th>Signal Type</th>
                    <th>Variance [sq-deg]</th>
                </tr>
                <tr>
                    <td>Lensed-LCDM</td>
                    <td>0.0036</td>
                </tr>
                <tr>
                    <td>Noise</td>
                    <td>0.0104</td>
                </tr>
                <tr>
                    <td>Dust</td>
                    <td>0.0003</td>
                </tr>
                <tr>
                    <td>&sigma;<sup>2</sup><sub>L</sub>+&sigma;<sup>2</sup><sub>N</sub></td>
                    <td>0.0140</td>
                </tr>
                <tr>
                    <td>&sigma;<sup>2</sup><sub>L+N</sub></td>
                    <td>0.0135</td>
                </tr>
                <tr>
                    <td>&sigma;<sup>2</sup><sub>L</sub>+&sigma;<sup>2</sup><sub>N</sub>+&sigma;<sup>2</sup><sub>D</sub></td>
                    <td>0.0143</td>
                </tr>
                <tr>
                    <td>&sigma;<sup>2</sup><sub>L+N+D</sub></td>
                    <td>0.0139</td>
                </tr>
            </table>
            <figcaption>
                Table of B2018 variance on alpha from EB fits
            </figcaption>
        </figure>

        <p>The sum of the variances between Lensed-LCDM, Noise and Dust correspond to the variance on the coadded spectra to within 4%.</p>
        
        <h3>Estimator Transfer Function?</h3>
        <p>
            Now we need to get an idea of which bandpowers matter most in our angle estimator.
        </p>
        <p>
            I do this by injecting a quasi-delta function -- i.e. setting a bandpower to some fixed amplitude whilst keeping all other bandpowers at zero -- into an EB or TB spectra &ell;bin-by-&ell;bin, recording the resulting alpha estimates (see below figure for example).
        </p>
        <figure>
            <img src="figs/estimator_xfer_example.gif">
            <figcaption>

            </figcaption>
        </figure>
        <p>
            The figure below shows resulting alphas for four different amplitudes of our quasi-delta function.
        </p>
        <figure>

            <img src="figs/estimator_xfer_func.png">
            <figcaption>
                Exploring the effect on &alpha; for input delta functions for EB <b>(Top Row)</b> and TB <b>(Bottom
                Row)</b>. <b>Left Column</b> Resulting &alpha; estimate per bandpower as a function of Ell, the lines are color coded by the amplitude of the quasi-delta function used in the given spectra. <b>(Right Column)</b> The angle at each bandpower is divided by the angle Dl=1 (Dl=0.1 for EB) at that bandpower to confirm linearity -- an increase in the bandpower corresponds to a linear increase in angle for these amplitudes.
            </figcaption>
        </figure>
<p>
    We can see that the EB fit favors the lowest Ell's while TB favors Ell's around 150. And we can see why in the figure below which shows the the our matrix-purified simulations along with the functional form of our estimator at for different &alpha;s taken from figure 1 of <a href="Kaufman2013"></a>.
    For EB, since the EB power at high-&ell; grows faster, one could naively expect the estimator to be more sensitive at those higher &ell;-bins, but it looks like that's beat out by the lower sample variance at low-&ell;.
    This is because EB has lowest sample variance at low &ell;'s and while TB also has lower sample variance at low &ell;s, the TB spectra pivots about &ell;s of 50 and 200 in our model of global polarization rotation. See the figure below as an example
</p>

        <figure>
            <table cellpadding="0" cellspacing="0">
                <tr>
                    <td>
                        <img src="figs/tb_eb_spectra_example.png">
                    </td>
                </tr>
                <tr>
                    <td>
                        <img src="figs/polrot_example_kaufman2013.png">
                    </td>
                </tr>
            </table>

            <figcaption>

            </figcaption>
        </figure>

        <p>We can also see that, at small angles, the linearity of our estimator has been confirmed -- as I increase the amplitude of the bandpower, we see a linear increase in the resulting angle. This means that we can confidently predict changes in &alpha; based on relative differences in EB and TB spectra.</p>

        <p>With these two points in mind, we can establish a relationship between BB-band powers and &alpha; and then make predictions on &alpha; given some change in BB. I'll first re-fit &alpha; for B18, B2018 and B2018-rerun, but only using &ell;-bins</p>

        <figure>
            <img alt="Name pager" id="histpager2" src="#" onerror=this.src="figs/blank_6x4.png" width="100%"/>
            <figcaption>
                Histograms of &alpha; estimates for B2018 and my B2018-rerun for each EB/TB fit type; per signal type; and with and without matrix purification.
            </figcaption>
            <script type="text/javascript">
                pager.link("#histpager2",
                    {
                        'Signal Type|sig': ['Unlensed-LCDM|2','G. Dust|3','Lensed-LCDM|5','Noise|6','L-LCDM+Noise|7','L-LCDM+Noise+Dust|8'],
                        //'Purification Method|pure2': ['None|','Matrix|matrix_'],
                        'Simset|sernum2': ['B18|6614fgh','B2018|6614h','B2018-rerun|6600h'],
                        //'cmb x noise/dust|c': ['Off|','On|_cross'],
                        'Bins|bins': ['2-10|_bins_2_10','2-5|_bins_2_5','1-17|_bins_1_17'],
                    },
                    function(params) {
                        return 'figs/alpha_hist_'+params.sernum2+'matrix_'+params.sig+'_corr_cross'+params.bins+'.png';
                    });
                pager.setparams({
                    'sig': '2',
                    'bins': '_bins_2_5',
                    'sernum2': '6600h',
                    //'c': '',
                });
            </script>
        </figure>



</section>
<section><h2>Conclusions</h2>
    <p>

    </p>


    <h3>Next Steps</h3>

</section>

<hr>

<section class="appendix">
<h2 class="appendix">Appendix</h2>
    <h3>Footnotes</h3>
    <p>Click on the number to return to the main text.</p>
    <div class="footnote">
        <p>
        <sup><a name="ftn1" href="#sup1">[1]</a></sup>
        A more recent global rotation posting for BK18 exists, but to remain blind in this analysis I have not looked at it and do not link it here.
    </p>
    </div>
<!--    <h3>Code</h3>-->
<!--    <p>Below is a list of code that was used for this analysis. The code is committed to the pipeline and can be found in the <tt>analysis/beammap/</tt> directory.</p>-->
<!--    <p id="code"></p>-->

<!--    <h3>Data</h3>-->
<!--    <p id="data"></p>-->
    <h3>References</h3>

    <p id="references"></p>


    <p id="testp"></p>

    <script type="text/javascript">

        // Shorthand tags
        var codes = [
            "rps_fit_mirror_from_moon.m",
            ];

        // Posting titles
        var desc = [
            "Derives mirror parameters from observations of the moon.",
        ];

        // Make a list of references
        var post = document.getElementById("code");
        var msg = "<table class=\"code\">";
        for (var code in codes){
            msg = msg + "<tr><td><tt>"+codes[code]+"</tt></td><td> - </td><td>"+desc[code]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

    </script>

    <script type="text/javascript">

        // Shorthand tags
        var data = [
            "moonsch.mat",
            ];

        // Posting titles
        var desc = [
            "Metadata of Moon observations",
            ];

        // Make a list of references
        var post = document.getElementById("data");
        var msg = "<table class=\"code\">";
        for (var datum in data) {
            msg = msg + "<tr><td><tt>" + data[datum] + "</tt></td><td> - </td><td>" + desc[datum] + "</td>";
        }
        ;
        msg = msg + "</table>";
        post.innerHTML = msg;

    </script>



    <script type="text/javascript">

        // This my way of making shorthand links.
        // We'll make a couple arrays with the 'tag' and href information
        // and then look through each anchor element for the specified tag.
        // The anchors should then just look like: <a href="tagname"></a>
        // and the script will automatically fill in the hyperlings and text.


        var posting_dir = window.location.href; // What's the current url?

        var bkurl = "bicep.rc.fas.harvard.edu";
        var spurl = "bicep.usap.gov";

        // These are the possible places to find postings
        // The strings are for if you post your posting in that directory.
        var sitemap = {
            jcornelison: "../../../",   // /jcornelison/postings/
            bkcmb : "../../../../",     // /bkcmb/analysis_logbook/analysis/
            bicep3: "../../../",        //
            bicep_array: "../../../",   //
            bicep2: "",                 // We shouldn't be posting in these, but still have postings we can reference.
            keck  : "",                 // keck/analysis_logbook/analysis/
            spuder: "",                 // ~spuder/hieno_analysis_logboo
            bicep1: "",                 // ~bicep1/analysis_logbook_north/
            general_projects:"",
                   };
        // Logbook Site map:
        // personal:www/jcornelison/postings/
        // bkcmb:   www/bkcmb/analysis_logbook/analysis/
        // keck:    www/keck/analysis_logbook/analysis/
        // BICEP3:  www/bicep3/analysis_logbook/
        // BA:      www/bicep_array/analysis_logbook/
        // We shouldn't be posting in these, but still have postings.
        // bicep2:
        // keck:    www/keck/analysis_logbook/analysis/
        // spuder:  www/~spuder/hieno_analysis_logbook/
        // bicep1:  www/~bicep1/analysis_logbook_north/

        // Shorthand tags
        var tags = [
            "Carroll1990",
            "Harari1992",
            "Kaufman2013",
            "JBW2016",
            "EWB2016",
            "BKIX",
            "BKXII",
            "BKXIV",
            "BKXVII",
        ];

        // Links
        // Truncate the link down to the www directory in which it lies if you can.
        // This ensures that we can view the linked postings at Pole without the internet.
        var hrefs = [
            "papers/carroll1990.pdf",
            "papers/harari1992.pdf",
            "https://arxiv.org/pdf/1312.7877.pdf",
            "bkcmb/analysis_logbook/analysis/20160907_polrot/",
            "bkcmb/analysis_logbook/analysis/20161215_rot_sims_polrot/",
            "https://arxiv.org/pdf/1705.02523.pdf",
            "https://arxiv.org/pdf/2011.03483.pdf",
            "https://arxiv.org/pdf/2108.03316.pdf",
            "https://arxiv.org/pdf/2210.08038.pdf",


        ];


        // Posting titles
        var desc = [
            "Limits on a Lorentz- and parity-violating modification of electrodynamics",
            "Effects of a Nambu-Goldstone boson on the polarization of radio galaxies and the cosmic microwave background",
            "Self-Calibration of BICEP1 Three-Year Data and Constraints on Astrophysical Polarization Rotation",
            "Birefringence/Polarization rotation in K2015 and BK15",
            "Polarization Rotation Sims Global Rotation",
            "New Bounds on Anisotropies of CMB Polarization Rotation and Implications for Axion-Like Particles and Primordial Magnetic Fields",
            "Constraints on axion-like polarization oscillations in the cosmic microwave background",
            "Improved Constraints on axion-like polarization oscillations in the Cosmic Microwave Background",
            "Line of Sight Distortion Analysis: Estimates of Gravitational Lensing, Anisotropic Cosmic Birefringence, Patchy Reionization, and Systematic Errors",
        ];
        // Debug
        var posty = document.getElementById("testp");


        var preface = "";
        var keys = Object.keys(sitemap);
        // If we're not at pole or bicep, just post the full URL
        // If we are, go back to the www directory.
        if (posting_dir.match(new RegExp(bkurl))!=bkurl &
            posting_dir.match(new RegExp(spurl))!=spurl){
                preface = "http://" + bkurl+"/";
            }
        else {
            for (key in keys){
                if (posting_dir.match(new RegExp("/"+keys[key]+"/"))=="/"+keys[key]+"/"){
                    preface = sitemap[keys[key]];
                };
            };

        };

        // Add the prefixes we can.
        // Only add prefixes to directories in the sitemap so we don't break
        // external references.
        for (ref in hrefs) {
            for (key in keys) {

            // If there's a match, at the prefix and move on.
            if(hrefs[ref].match(new RegExp(keys[key] + "/"))==keys[key]+"/"){
                hrefs[ref] = preface+hrefs[ref];
                break;
            }
            };
        };

        // posty.innerHTML = preface;

        // Make a list of references
        var post = document.getElementById("references");
        var msg = "<table>";
        for (var tag in tags){
            msg = msg + "<tr><td><a href="+tags[tag]+"></a></td><td> - </td><td>"+desc[tag]+"</td>";
        };
        msg = msg+ "</table>";
        post.innerHTML = msg;

        // Look through all the hyperlinks and insert the proper links to the postings
        var links = document.getElementsByTagName("A");
        for (var link in links){
            for (var tag in tags){
                if (links[link].href.endsWith(tags[tag])){
                    links[link].text = "("+tags[tag]+")";
                    links[link].href = hrefs[tag];
                    links[link].target = "_blank";
                }
            }
        }

    </script>
</section>
</body>
